{
    "sourceFile": "src/app/api/itinerary/route.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1766824749075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1766863737406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,85 +1,279 @@\n \n \n import { NextResponse } from \"next/server\";\n \n-// This route builds a 2â€“3 hour itinerary.\n-// For now it returns a safe fallback plan.\n-// You can later replace the body with Google Places + Routes logic.\n+// Force Node runtime for stable env + fetch behavior\n+export const runtime = \"nodejs\";\n \n+const PLACES_SEARCH_TEXT = \"https://places.googleapis.com/v1/places:searchText\";\n+const PLACE_DETAILS_BASE = \"https://places.googleapis.com/v1/places/\";\n+const ROUTES_COMPUTE = \"https://routes.googleapis.com/directions/v2:computeRoutes\";\n+\n+type LatLng = { latitude: number; longitude: number };\n+\n+type ParkingOption = {\n+  name: string;\n+  address?: string;\n+  mapsUri?: string;\n+};\n+\n+type StopDetails = {\n+  placeId: string;\n+  title: string;\n+  address?: string;\n+  lat: number;\n+  lng: number;\n+  mapsUri?: string;\n+\n+  rating?: number;\n+  userRatingCount?: number;\n+  priceLevel?: string;\n+  openNow?: boolean;\n+  weekdayText?: string[];\n+  photoUrl?: string;\n+  reviewSnippet?: string;\n+  parking?: ParkingOption;\n+};\n+\n+type PlanItem =\n+  | ({ type: \"stop\"; durationMin: number } & StopDetails)\n+  | { type: \"travel\"; title: string; durationMin: number; mode: \"DRIVE\" };\n+\n+function clamp(n: number, min: number, max: number) {\n+  if (!Number.isFinite(n)) return min;\n+  return Math.max(min, Math.min(max, n));\n+}\n+\n+function toMinsFromDuration(durationStr: string): number {\n+  // e.g. \"1234s\"\n+  const secs = Number(String(durationStr ?? \"\").replace(\"s\", \"\")) || 900;\n+  return Math.max(5, Math.round(secs / 60));\n+}\n+\n+function safeText(s: any, maxLen: number) {\n+  const t = String(s ?? \"\").trim();\n+  if (!t) return undefined;\n+  return t.length > maxLen ? `${t.slice(0, maxLen - 1)}â€¦` : t;\n+}\n+\n+async function googleFetch(url: string, opts: RequestInit & { fieldMask?: string; key: string }) {\n+  const { fieldMask, key, ...rest } = opts;\n+  const headers: Record<string, string> = {\n+    \"Content-Type\": \"application/json\",\n+    \"X-Goog-Api-Key\": key,\n+    ...(rest.headers as Record<string, string> | undefined),\n+  };\n+  // Places API (New) requires FieldMask for response fields\n+  if (fieldMask) headers[\"X-Goog-FieldMask\"] = fieldMask;\n+\n+  return fetch(url, { ...rest, headers });\n+}\n+\n+async function searchPlacesText(key: string, textQuery: string, maxResultCount = 10) {\n+  const res = await googleFetch(PLACES_SEARCH_TEXT, {\n+    key,\n+    method: \"POST\",\n+    body: JSON.stringify({ textQuery, maxResultCount }),\n+    fieldMask:\n+      \"places.id,places.displayName,places.formattedAddress,places.location,places.types,places.mapsUri\",\n+  });\n+\n+  if (!res.ok) throw new Error(await res.text());\n+  const data = await res.json();\n+  return (data?.places ?? []) as any[];\n+}\n+\n+async function getPlaceDetails(key: string, placeId: string) {\n+  const url = `${PLACE_DETAILS_BASE}${encodeURIComponent(placeId)}`;\n+  const res = await googleFetch(url, {\n+    key,\n+    method: \"GET\",\n+    fieldMask:\n+      \"id,displayName,formattedAddress,location,rating,userRatingCount,priceLevel,regularOpeningHours,photos,reviews,mapsUri\",\n+  });\n+  if (!res.ok) throw new Error(await res.text());\n+  return (await res.json()) as any;\n+}\n+\n+async function getPhotoUri(key: string, photoName: string, maxWidthPx = 900) {\n+  // /v1/{name}/media?maxWidthPx=...&skipHttpRedirect=true\n+  const url = `https://places.googleapis.com/v1/${photoName}/media?maxWidthPx=${maxWidthPx}&skipHttpRedirect=true`;\n+  const res = await googleFetch(url, { key, method: \"GET\", fieldMask: \"photoUri\" });\n+  if (!res.ok) return undefined;\n+  const data = await res.json();\n+  return data?.photoUri as string | undefined;\n+}\n+\n+async function computeDriveMinutes(key: string, origin: LatLng, destination: LatLng) {\n+  const res = await googleFetch(ROUTES_COMPUTE, {\n+    key,\n+    method: \"POST\",\n+    body: JSON.stringify({\n+      origin: { location: { latLng: origin } },\n+      destination: { location: { latLng: destination } },\n+      travelMode: \"DRIVE\",\n+    }),\n+    fieldMask: \"routes.duration\",\n+  });\n+\n+  if (!res.ok) throw new Error(await res.text());\n+  const data = await res.json();\n+  const dur = data?.routes?.[0]?.duration ?? \"900s\";\n+  return toMinsFromDuration(dur);\n+}\n+\n+async function findParkingNear(key: string, placeTitle: string, destinationLabel: string) {\n+  const q = `parking near ${placeTitle} ${destinationLabel}`;\n+  const results = await searchPlacesText(key, q, 5);\n+  const best = results?.[0];\n+  if (!best) return undefined;\n+\n+  return {\n+    name: best?.displayName?.text ?? \"Parking\",\n+    address: best?.formattedAddress,\n+    mapsUri: best?.mapsUri,\n+  } as ParkingOption;\n+}\n+\n+function pickStopCount(totalMinutes: number) {\n+  return totalMinutes <= 140 ? 2 : 3;\n+}\n+\n+function splitStopDurations(totalMinutes: number, travelTotal: number, stopCount: number) {\n+  const remaining = Math.max(60, totalMinutes - travelTotal);\n+  if (stopCount === 2) {\n+    const a = Math.floor(remaining * 0.55);\n+    return [a, remaining - a];\n+  }\n+  const a = Math.floor(remaining * 0.42);\n+  const b = Math.floor(remaining * 0.35);\n+  return [a, b, remaining - a - b];\n+}\n+\n export async function POST(req: Request) {\n+  console.log(\"ðŸ”¥ /api/itinerary HIT (GOOGLE+DRIVE)\");\n+\n   try {\n-    const body = await req.json();\n+    const body = await req.json().catch(() => ({}));\n+\n     const destination = String(body?.destination ?? \"\").trim();\n-    const totalMinutes = Number(body?.totalMinutes ?? 150);\n+    const totalMinutes = clamp(Number(body?.totalMinutes ?? 150), 120, 180);\n     const vibe = String(body?.vibe ?? \"culture\");\n \n     if (!destination) {\n       return NextResponse.json({ error: \"Destination is required\" }, { status: 400 });\n     }\n \n-    const minutes = clamp(totalMinutes, 120, 180);\n+    const key = process.env.GOOGLE_MAPS_API_KEY;\n+    if (!key) {\n+      return NextResponse.json(\n+        { error: \"Missing GOOGLE_MAPS_API_KEY. Add it to .env.local and restart npm run dev.\" },\n+        { status: 500 }\n+      );\n+    }\n \n-    // Simple 2â€“3 hour structure\n-    const stopCount = minutes <= 140 ? 2 : 3;\n-    const travelMinEach = 12;\n-    const travelTotal = (stopCount - 1) * travelMinEach;\n-    const remaining = Math.max(60, minutes - travelTotal);\n+    const query =\n+      vibe === \"adventure\"\n+        ? `top viewpoints parks trails in ${destination}`\n+        : vibe === \"foodie\"\n+        ? `best cafes restaurants bakeries in ${destination}`\n+        : vibe === \"relaxed\"\n+        ? `waterfront parks cafes in ${destination}`\n+        : `top tourist attractions museums in ${destination}`;\n \n-    const stopDurations =\n-      stopCount === 2\n-        ? [Math.floor(remaining * 0.55), remaining - Math.floor(remaining * 0.55)]\n-        : [\n-            Math.floor(remaining * 0.42),\n-            Math.floor(remaining * 0.35),\n-            remaining - Math.floor(remaining * 0.42) - Math.floor(remaining * 0.35),\n-          ];\n+    const candidates = await searchPlacesText(key, query, 12);\n+    if (candidates.length < 2) {\n+      return NextResponse.json({ error: \"Not enough places found\" }, { status: 404 });\n+    }\n \n-    const byVibe: Record<string, string[]> = {\n-      relaxed: [\"Waterfront stroll\", \"Coffee break\", \"Scenic viewpoint\"],\n-      foodie: [\"Top-rated cafÃ©\", \"Local specialty\", \"Dessert stop\"],\n-      adventure: [\"Easy trail\", \"Lookout point\", \"Recovery cafÃ©\"],\n-      culture: [\"Museum or gallery\", \"Historic walk\", \"Local landmark\"],\n-    };\n+    const stopCount = pickStopCount(totalMinutes);\n+    const chosen = candidates.slice(0, stopCount);\n \n-    const titles = byVibe[vibe] ?? byVibe.culture;\n+    const stops: StopDetails[] = await Promise.all(\n+      chosen.map(async (p) => {\n+        const placeId = String(p?.id ?? \"\");\n+        if (!placeId) throw new Error(\"Google Places returned an item without id\");\n \n-    const items: Array<{\n-      type: \"stop\" | \"travel\";\n-      title: string;\n-      durationMin: number;\n-    }> = [];\n+        const details = await getPlaceDetails(key, placeId);\n \n-    for (let i = 0; i < stopCount; i++) {\n-      items.push({\n-        type: \"stop\",\n-        title: `${titles[i] ?? \"Stop\"} in ${destination}`,\n-        durationMin: Math.max(25, stopDurations[i]),\n-      });\n+        // Photo\n+        let photoUrl: string | undefined;\n+        const firstPhotoName = details?.photos?.[0]?.name;\n+        if (firstPhotoName) {\n+          photoUrl = await getPhotoUri(key, firstPhotoName, 1000);\n+        }\n \n-      if (i < stopCount - 1) {\n-        items.push({\n-          type: \"travel\",\n-          title: \"Walk to next stop\",\n-          durationMin: travelMinEach,\n-        });\n+        // Reviews\n+        const reviewSnippet = safeText(details?.reviews?.[0]?.text?.text, 170);\n+\n+        // Opening hours\n+        const openNow = details?.regularOpeningHours?.openNow;\n+        const weekdayText = Array.isArray(details?.regularOpeningHours?.weekdayDescriptions)\n+          ? (details.regularOpeningHours.weekdayDescriptions as string[])\n+          : undefined;\n+\n+        // Parking (best effort)\n+        let parking: ParkingOption | undefined;\n+        try {\n+          parking = await findParkingNear(key, details?.displayName?.text ?? \"\", destination);\n+        } catch {\n+          parking = undefined;\n+        }\n+\n+        return {\n+          placeId,\n+          title: details?.displayName?.text ?? \"Place\",\n+          address: details?.formattedAddress,\n+          lat: Number(details?.location?.latitude),\n+          lng: Number(details?.location?.longitude),\n+          mapsUri: details?.mapsUri,\n+\n+          rating: typeof details?.rating === \"number\" ? details.rating : undefined,\n+          userRatingCount:\n+            typeof details?.userRatingCount === \"number\" ? details.userRatingCount : undefined,\n+          priceLevel: typeof details?.priceLevel === \"string\" ? details.priceLevel : undefined,\n+          openNow: typeof openNow === \"boolean\" ? openNow : undefined,\n+          weekdayText,\n+          photoUrl,\n+          reviewSnippet,\n+          parking,\n+        };\n+      })\n+    );\n+\n+    // Travel minutes between stops (DRIVE)\n+    const travelMins: number[] = [];\n+    for (let i = 0; i < stops.length - 1; i++) {\n+      const a = stops[i];\n+      const b = stops[i + 1];\n+      const mins = await computeDriveMinutes(\n+        key,\n+        { latitude: a.lat, longitude: a.lng },\n+        { latitude: b.lat, longitude: b.lng }\n+      );\n+      travelMins.push(mins);\n+    }\n+\n+    const travelTotal = travelMins.reduce((x, y) => x + y, 0);\n+    const stopDurations = splitStopDurations(totalMinutes, travelTotal, stops.length);\n+\n+    const items: PlanItem[] = [];\n+    for (let i = 0; i < stops.length; i++) {\n+      items.push({ type: \"stop\", durationMin: Math.max(25, stopDurations[i] ?? 40), ...stops[i] });\n+      if (i < travelMins.length) {\n+        items.push({ type: \"travel\", title: \"Drive to next stop\", durationMin: travelMins[i], mode: \"DRIVE\" });\n       }\n     }\n \n     return NextResponse.json({\n       destination,\n-      totalMinutes: minutes,\n+      totalMinutes,\n       vibe,\n+      source: \"google\",\n       items,\n     });\n-  } catch (err) {\n-    return NextResponse.json(\n-      { error: \"Failed to generate itinerary\" },\n-      { status: 500 }\n-    );\n+  } catch (e) {\n+    const msg = e instanceof Error ? e.message : \"Failed to generate itinerary\";\n+    return NextResponse.json({ error: msg }, { status: 500 });\n   }\n-}\n-\n-function clamp(n: number, min: number, max: number) {\n-  if (!Number.isFinite(n)) return min;\n-  return Math.max(min, Math.min(max, n));\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1766864004929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,10 +74,9 @@\n     key,\n     method: \"POST\",\n     body: JSON.stringify({ textQuery, maxResultCount }),\n     fieldMask:\n-      \"places.id,places.displayName,places.formattedAddress,places.location,places.types,places.mapsUri\",\n-  });\n+        \"places.id,places.displayName,places.formattedAddress,places.location,places.types\",  });\n \n   if (!res.ok) throw new Error(await res.text());\n   const data = await res.json();\n   return (data?.places ?? []) as any[];\n"
                },
                {
                    "date": 1766864044242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,9 +129,9 @@\n \n   return {\n     name: best?.displayName?.text ?? \"Parking\",\n     address: best?.formattedAddress,\n-    mapsUri: best?.mapsUri,\n+    // mapsUri is NOT available from places:searchText results\n   } as ParkingOption;\n }\n \n function pickStopCount(totalMinutes: number) {\n"
                },
                {
                    "date": 1766864124578,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-\n-\n import { NextResponse } from \"next/server\";\n \n // Force Node runtime for stable env + fetch behavior\n export const runtime = \"nodejs\";\n@@ -87,9 +85,9 @@\n   const res = await googleFetch(url, {\n     key,\n     method: \"GET\",\n     fieldMask:\n-      \"id,displayName,formattedAddress,location,rating,userRatingCount,priceLevel,regularOpeningHours,photos,reviews,mapsUri\",\n+      \"id,displayName,formattedAddress,location,rating,userRatingCount,priceLevel,regularOpeningHours,photos,reviews,googleMapsUri\",\n   });\n   if (!res.ok) throw new Error(await res.text());\n   return (await res.json()) as any;\n }\n@@ -224,9 +222,9 @@\n           title: details?.displayName?.text ?? \"Place\",\n           address: details?.formattedAddress,\n           lat: Number(details?.location?.latitude),\n           lng: Number(details?.location?.longitude),\n-          mapsUri: details?.mapsUri,\n+          mapsUri: details?.googleMapsUri,\n \n           rating: typeof details?.rating === \"number\" ? details.rating : undefined,\n           userRatingCount:\n             typeof details?.userRatingCount === \"number\" ? details.userRatingCount : undefined,\n"
                },
                {
                    "date": 1766864411914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,276 +1,140 @@\n-import { NextResponse } from \"next/server\";\n+import { useState } from \"react\";\n+import { PlanItem, TRAVEL_STYLES } from \"./types\"; // Assuming types are imported from a types file\n \n-// Force Node runtime for stable env + fetch behavior\n-export const runtime = \"nodejs\";\n-\n-const PLACES_SEARCH_TEXT = \"https://places.googleapis.com/v1/places:searchText\";\n-const PLACE_DETAILS_BASE = \"https://places.googleapis.com/v1/places/\";\n-const ROUTES_COMPUTE = \"https://routes.googleapis.com/directions/v2:computeRoutes\";\n-\n-type LatLng = { latitude: number; longitude: number };\n-\n-type ParkingOption = {\n-  name: string;\n-  address?: string;\n-  mapsUri?: string;\n-};\n-\n-type StopDetails = {\n-  placeId: string;\n-  title: string;\n-  address?: string;\n-  lat: number;\n-  lng: number;\n-  mapsUri?: string;\n-\n-  rating?: number;\n-  userRatingCount?: number;\n-  priceLevel?: string;\n-  openNow?: boolean;\n-  weekdayText?: string[];\n-  photoUrl?: string;\n-  reviewSnippet?: string;\n-  parking?: ParkingOption;\n-};\n-\n-type PlanItem =\n-  | ({ type: \"stop\"; durationMin: number } & StopDetails)\n-  | { type: \"travel\"; title: string; durationMin: number; mode: \"DRIVE\" };\n-\n-function clamp(n: number, min: number, max: number) {\n-  if (!Number.isFinite(n)) return min;\n-  return Math.max(min, Math.min(max, n));\n-}\n-\n-function toMinsFromDuration(durationStr: string): number {\n-  // e.g. \"1234s\"\n-  const secs = Number(String(durationStr ?? \"\").replace(\"s\", \"\")) || 900;\n-  return Math.max(5, Math.round(secs / 60));\n-}\n-\n-function safeText(s: any, maxLen: number) {\n-  const t = String(s ?? \"\").trim();\n-  if (!t) return undefined;\n-  return t.length > maxLen ? `${t.slice(0, maxLen - 1)}â€¦` : t;\n-}\n-\n-async function googleFetch(url: string, opts: RequestInit & { fieldMask?: string; key: string }) {\n-  const { fieldMask, key, ...rest } = opts;\n-  const headers: Record<string, string> = {\n-    \"Content-Type\": \"application/json\",\n-    \"X-Goog-Api-Key\": key,\n-    ...(rest.headers as Record<string, string> | undefined),\n-  };\n-  // Places API (New) requires FieldMask for response fields\n-  if (fieldMask) headers[\"X-Goog-FieldMask\"] = fieldMask;\n-\n-  return fetch(url, { ...rest, headers });\n-}\n-\n-async function searchPlacesText(key: string, textQuery: string, maxResultCount = 10) {\n-  const res = await googleFetch(PLACES_SEARCH_TEXT, {\n-    key,\n-    method: \"POST\",\n-    body: JSON.stringify({ textQuery, maxResultCount }),\n-    fieldMask:\n-        \"places.id,places.displayName,places.formattedAddress,places.location,places.types\",  });\n-\n-  if (!res.ok) throw new Error(await res.text());\n-  const data = await res.json();\n-  return (data?.places ?? []) as any[];\n-}\n-\n-async function getPlaceDetails(key: string, placeId: string) {\n-  const url = `${PLACE_DETAILS_BASE}${encodeURIComponent(placeId)}`;\n-  const res = await googleFetch(url, {\n-    key,\n-    method: \"GET\",\n-    fieldMask:\n-      \"id,displayName,formattedAddress,location,rating,userRatingCount,priceLevel,regularOpeningHours,photos,reviews,googleMapsUri\",\n+export default function Home() {\n+  const [destination, setDestination] = useState(\"\");\n+  const [style, setStyle] = useState(TRAVEL_STYLES[0].key);\n+  const [duration, setDuration] = useState(150);\n+  const [startTime, setStartTime] = useState<string>(() => {\n+    const now = new Date();\n+    // round up to next 5 minutes\n+    const mins = now.getMinutes();\n+    const rounded = Math.ceil(mins / 5) * 5;\n+    now.setMinutes(rounded, 0, 0);\n+    const hh = String(now.getHours()).padStart(2, \"0\");\n+    const mm = String(now.getMinutes()).padStart(2, \"0\");\n+    return `${hh}:${mm}`;\n   });\n-  if (!res.ok) throw new Error(await res.text());\n-  return (await res.json()) as any;\n-}\n+  const [plan, setPlan] = useState<{ items: PlanItem[]; destination: string; totalMinutes: number } | null>(null);\n+  const [error, setError] = useState<string | null>(null);\n+  const [loading, setLoading] = useState(false);\n \n-async function getPhotoUri(key: string, photoName: string, maxWidthPx = 900) {\n-  // /v1/{name}/media?maxWidthPx=...&skipHttpRedirect=true\n-  const url = `https://places.googleapis.com/v1/${photoName}/media?maxWidthPx=${maxWidthPx}&skipHttpRedirect=true`;\n-  const res = await googleFetch(url, { key, method: \"GET\", fieldMask: \"photoUri\" });\n-  if (!res.ok) return undefined;\n-  const data = await res.json();\n-  return data?.photoUri as string | undefined;\n-}\n+  const timeline = plan ? buildTimeline(plan.items as PlanItem[], startTime) : null;\n \n-async function computeDriveMinutes(key: string, origin: LatLng, destination: LatLng) {\n-  const res = await googleFetch(ROUTES_COMPUTE, {\n-    key,\n-    method: \"POST\",\n-    body: JSON.stringify({\n-      origin: { location: { latLng: origin } },\n-      destination: { location: { latLng: destination } },\n-      travelMode: \"DRIVE\",\n-    }),\n-    fieldMask: \"routes.duration\",\n-  });\n+  // Helper functions\n+  function formatPriceLevel(level?: string) {\n+    if (!level) return \"N/A\";\n+    const map: Record<string, string> = { cheap: \"$\", moderate: \"$$\", expensive: \"$$$\" };\n+    return map[level] || level;\n+  }\n \n-  if (!res.ok) throw new Error(await res.text());\n-  const data = await res.json();\n-  const dur = data?.routes?.[0]?.duration ?? \"900s\";\n-  return toMinsFromDuration(dur);\n-}\n+  function formatRating(rating?: number) {\n+    if (rating === undefined) return \"N/A\";\n+    return rating.toFixed(1);\n+  }\n \n-async function findParkingNear(key: string, placeTitle: string, destinationLabel: string) {\n-  const q = `parking near ${placeTitle} ${destinationLabel}`;\n-  const results = await searchPlacesText(key, q, 5);\n-  const best = results?.[0];\n-  if (!best) return undefined;\n+  function parseHHMMToDate(hhmm: string) {\n+    const [hhStr, mmStr] = (hhmm || \"\").split(\":\");\n+    const hh = Number(hhStr);\n+    const mm = Number(mmStr);\n+    const d = new Date();\n+    d.setSeconds(0, 0);\n+    d.setHours(Number.isFinite(hh) ? hh : d.getHours(), Number.isFinite(mm) ? mm : d.getMinutes(), 0, 0);\n+    return d;\n+  }\n \n-  return {\n-    name: best?.displayName?.text ?? \"Parking\",\n-    address: best?.formattedAddress,\n-    // mapsUri is NOT available from places:searchText results\n-  } as ParkingOption;\n-}\n+  function addMinutes(d: Date, minutes: number) {\n+    const out = new Date(d.getTime());\n+    out.setMinutes(out.getMinutes() + minutes);\n+    return out;\n+  }\n \n-function pickStopCount(totalMinutes: number) {\n-  return totalMinutes <= 140 ? 2 : 3;\n-}\n+  function formatTime(d: Date) {\n+    // 12-hour with AM/PM\n+    return d.toLocaleTimeString([], { hour: \"numeric\", minute: \"2-digit\" });\n+  }\n \n-function splitStopDurations(totalMinutes: number, travelTotal: number, stopCount: number) {\n-  const remaining = Math.max(60, totalMinutes - travelTotal);\n-  if (stopCount === 2) {\n-    const a = Math.floor(remaining * 0.55);\n-    return [a, remaining - a];\n+  function buildTimeline(items: PlanItem[], startHHMM: string) {\n+    const start = parseHHMMToDate(startHHMM);\n+    let cursor = start;\n+    return items.map((it) => {\n+      const from = cursor;\n+      const to = addMinutes(cursor, Math.max(0, it.durationMin || 0));\n+      cursor = to;\n+      return { from, to };\n+    });\n   }\n-  const a = Math.floor(remaining * 0.42);\n-  const b = Math.floor(remaining * 0.35);\n-  return [a, b, remaining - a - b];\n-}\n \n-export async function POST(req: Request) {\n-  console.log(\"ðŸ”¥ /api/itinerary HIT (GOOGLE+DRIVE)\");\n+  async function onQuickDemo() {\n+    setDestination(\"San Francisco\");\n+    setStyle(\"culture\");\n+    setDuration(150);\n+    setStartTime(\"14:00\");\n+    // ... other logic to generate demo plan\n+  }\n \n-  try {\n-    const body = await req.json().catch(() => ({}));\n+  return (\n+    <div>\n+      <div className=\"planner-card grid md:grid-cols-4 gap-4\">\n+        <div className=\"md:col-span-2\">\n+          <label className=\"text-xs text-white/60\">Destination</label>\n+          <input\n+            type=\"text\"\n+            value={destination}\n+            onChange={(e) => setDestination(e.target.value)}\n+            className=\"mt-1 w-full rounded-xl border border-white/15 bg-black/30 px-3 py-2 text-sm text-white outline-none transition focus:border-white/25\"\n+          />\n+        </div>\n+        <div>\n+          <label className=\"text-xs text-white/60\">Duration</label>\n+          <input\n+            type=\"number\"\n+            value={duration}\n+            onChange={(e) => setDuration(Number(e.target.value))}\n+            className=\"mt-1 w-full rounded-xl border border-white/15 bg-black/30 px-3 py-2 text-sm text-white outline-none transition focus:border-white/25\"\n+          />\n+        </div>\n+        <div>\n+          <label className=\"text-xs text-white/60\">Start time</label>\n+          <input\n+            type=\"time\"\n+            value={startTime}\n+            onChange={(e) => setStartTime(e.target.value)}\n+            className=\"mt-1 w-full rounded-xl border border-white/15 bg-black/30 px-3 py-2 text-sm text-white outline-none transition focus:border-white/25\"\n+          />\n+        </div>\n+      </div>\n \n-    const destination = String(body?.destination ?? \"\").trim();\n-    const totalMinutes = clamp(Number(body?.totalMinutes ?? 150), 120, 180);\n-    const vibe = String(body?.vibe ?? \"culture\");\n-\n-    if (!destination) {\n-      return NextResponse.json({ error: \"Destination is required\" }, { status: 400 });\n-    }\n-\n-    const key = process.env.GOOGLE_MAPS_API_KEY;\n-    if (!key) {\n-      return NextResponse.json(\n-        { error: \"Missing GOOGLE_MAPS_API_KEY. Add it to .env.local and restart npm run dev.\" },\n-        { status: 500 }\n-      );\n-    }\n-\n-    const query =\n-      vibe === \"adventure\"\n-        ? `top viewpoints parks trails in ${destination}`\n-        : vibe === \"foodie\"\n-        ? `best cafes restaurants bakeries in ${destination}`\n-        : vibe === \"relaxed\"\n-        ? `waterfront parks cafes in ${destination}`\n-        : `top tourist attractions museums in ${destination}`;\n-\n-    const candidates = await searchPlacesText(key, query, 12);\n-    if (candidates.length < 2) {\n-      return NextResponse.json({ error: \"Not enough places found\" }, { status: 404 });\n-    }\n-\n-    const stopCount = pickStopCount(totalMinutes);\n-    const chosen = candidates.slice(0, stopCount);\n-\n-    const stops: StopDetails[] = await Promise.all(\n-      chosen.map(async (p) => {\n-        const placeId = String(p?.id ?? \"\");\n-        if (!placeId) throw new Error(\"Google Places returned an item without id\");\n-\n-        const details = await getPlaceDetails(key, placeId);\n-\n-        // Photo\n-        let photoUrl: string | undefined;\n-        const firstPhotoName = details?.photos?.[0]?.name;\n-        if (firstPhotoName) {\n-          photoUrl = await getPhotoUri(key, firstPhotoName, 1000);\n-        }\n-\n-        // Reviews\n-        const reviewSnippet = safeText(details?.reviews?.[0]?.text?.text, 170);\n-\n-        // Opening hours\n-        const openNow = details?.regularOpeningHours?.openNow;\n-        const weekdayText = Array.isArray(details?.regularOpeningHours?.weekdayDescriptions)\n-          ? (details.regularOpeningHours.weekdayDescriptions as string[])\n-          : undefined;\n-\n-        // Parking (best effort)\n-        let parking: ParkingOption | undefined;\n-        try {\n-          parking = await findParkingNear(key, details?.displayName?.text ?? \"\", destination);\n-        } catch {\n-          parking = undefined;\n-        }\n-\n-        return {\n-          placeId,\n-          title: details?.displayName?.text ?? \"Place\",\n-          address: details?.formattedAddress,\n-          lat: Number(details?.location?.latitude),\n-          lng: Number(details?.location?.longitude),\n-          mapsUri: details?.googleMapsUri,\n-\n-          rating: typeof details?.rating === \"number\" ? details.rating : undefined,\n-          userRatingCount:\n-            typeof details?.userRatingCount === \"number\" ? details.userRatingCount : undefined,\n-          priceLevel: typeof details?.priceLevel === \"string\" ? details.priceLevel : undefined,\n-          openNow: typeof openNow === \"boolean\" ? openNow : undefined,\n-          weekdayText,\n-          photoUrl,\n-          reviewSnippet,\n-          parking,\n-        };\n-      })\n-    );\n-\n-    // Travel minutes between stops (DRIVE)\n-    const travelMins: number[] = [];\n-    for (let i = 0; i < stops.length - 1; i++) {\n-      const a = stops[i];\n-      const b = stops[i + 1];\n-      const mins = await computeDriveMinutes(\n-        key,\n-        { latitude: a.lat, longitude: a.lng },\n-        { latitude: b.lat, longitude: b.lng }\n-      );\n-      travelMins.push(mins);\n-    }\n-\n-    const travelTotal = travelMins.reduce((x, y) => x + y, 0);\n-    const stopDurations = splitStopDurations(totalMinutes, travelTotal, stops.length);\n-\n-    const items: PlanItem[] = [];\n-    for (let i = 0; i < stops.length; i++) {\n-      items.push({ type: \"stop\", durationMin: Math.max(25, stopDurations[i] ?? 40), ...stops[i] });\n-      if (i < travelMins.length) {\n-        items.push({ type: \"travel\", title: \"Drive to next stop\", durationMin: travelMins[i], mode: \"DRIVE\" });\n-      }\n-    }\n-\n-    return NextResponse.json({\n-      destination,\n-      totalMinutes,\n-      vibe,\n-      source: \"google\",\n-      items,\n-    });\n-  } catch (e) {\n-    const msg = e instanceof Error ? e.message : \"Failed to generate itinerary\";\n-    return NextResponse.json({ error: msg }, { status: 500 });\n-  }\n+      {plan && (\n+        <div className=\"preview-header\">\n+          <h2>\n+            {plan.destination || \"â€”\"} â€¢ {plan.totalMinutes} min â€¢ {TRAVEL_STYLES.find((s) => s.key === style)?.label}\n+            {timeline && timeline.length ? (\n+              <span className=\"ml-2 text-white/55\">\n+                â€¢ {formatTime(timeline[0].from)}â€“{formatTime(timeline[timeline.length - 1].to)}\n+              </span>\n+            ) : null}\n+          </h2>\n+          <div className=\"plan-items\">\n+            {plan.items.map((it, idx) => (\n+              <div key={idx} className=\"plan-item-card\">\n+                <div className=\"flex items-center justify-between gap-3\">\n+                  <div className=\"flex items-center gap-2\">\n+                    <div className=\"text-sm font-semibold\">{it.type === \"stop\" ? \"Stop\" : \"Travel\"}</div>\n+                    {timeline?.[idx] ? (\n+                      <span className=\"rounded-full border border-white/15 bg-white/5 px-2 py-0.5 text-xs text-white/75\">\n+                        {formatTime(timeline[idx].from)}â€“{formatTime(timeline[idx].to)}\n+                      </span>\n+                    ) : null}\n+                  </div>\n+                  <div className=\"text-xs text-white/55\">{it.durationMin} min</div>\n+                </div>\n+                {/* Additional item details here */}\n+              </div>\n+            ))}\n+          </div>\n+        </div>\n+      )}\n+    </div>\n+  );\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1766864762158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,140 +1,267 @@\n-import { useState } from \"react\";\n-import { PlanItem, TRAVEL_STYLES } from \"./types\"; // Assuming types are imported from a types file\n+import { NextResponse } from \"next/server\";\n \n-export default function Home() {\n-  const [destination, setDestination] = useState(\"\");\n-  const [style, setStyle] = useState(TRAVEL_STYLES[0].key);\n-  const [duration, setDuration] = useState(150);\n-  const [startTime, setStartTime] = useState<string>(() => {\n-    const now = new Date();\n-    // round up to next 5 minutes\n-    const mins = now.getMinutes();\n-    const rounded = Math.ceil(mins / 5) * 5;\n-    now.setMinutes(rounded, 0, 0);\n-    const hh = String(now.getHours()).padStart(2, \"0\");\n-    const mm = String(now.getMinutes()).padStart(2, \"0\");\n-    return `${hh}:${mm}`;\n+// Force Node runtime for stable env + fetch behavior\n+export const runtime = \"nodejs\";\n+\n+const PLACES_SEARCH_TEXT = \"https://places.googleapis.com/v1/places:searchText\";\n+const PLACE_DETAILS_BASE = \"https://places.googleapis.com/v1/places/\";\n+const ROUTES_COMPUTE = \"https://routes.googleapis.com/directions/v2:computeRoutes\";\n+\n+type LatLng = { latitude: number; longitude: number };\n+\n+type ParkingOption = {\n+  name: string;\n+  address?: string;\n+  mapsUri?: string;\n+};\n+\n+type StopDetails = {\n+  placeId: string;\n+  title: string;\n+  address?: string;\n+  lat: number;\n+  lng: number;\n+  mapsUri?: string;\n+\n+  rating?: number;\n+  userRatingCount?: number;\n+  priceLevel?: string;\n+  openNow?: boolean;\n+  weekdayText?: string[];\n+  photoUrl?: string;\n+  reviewSnippet?: string;\n+  parking?: ParkingOption;\n+};\n+\n+type PlanItem =\n+  | ({ type: \"stop\"; durationMin: number } & StopDetails)\n+  | { type: \"travel\"; title: string; durationMin: number; mode: \"DRIVE\" };\n+\n+function clamp(n: number, min: number, max: number) {\n+  if (!Number.isFinite(n)) return min;\n+  return Math.max(min, Math.min(max, n));\n+}\n+\n+function toMinsFromDuration(durationStr: string): number {\n+  const secs = Number(String(durationStr ?? \"\").replace(\"s\", \"\")) || 900;\n+  return Math.max(5, Math.round(secs / 60));\n+}\n+\n+function safeText(s: any, maxLen: number) {\n+  const t = String(s ?? \"\").trim();\n+  if (!t) return undefined;\n+  return t.length > maxLen ? `${t.slice(0, maxLen - 1)}â€¦` : t;\n+}\n+\n+async function googleFetch(url: string, opts: RequestInit & { fieldMask?: string; key: string }) {\n+  const { fieldMask, key, ...rest } = opts;\n+  const headers: Record<string, string> = {\n+    \"Content-Type\": \"application/json\",\n+    \"X-Goog-Api-Key\": key,\n+    ...(rest.headers as Record<string, string> | undefined),\n+  };\n+  if (fieldMask) headers[\"X-Goog-FieldMask\"] = fieldMask;\n+  return fetch(url, { ...rest, headers });\n+}\n+\n+async function searchPlacesText(key: string, textQuery: string, maxResultCount = 10) {\n+  const res = await googleFetch(PLACES_SEARCH_TEXT, {\n+    key,\n+    method: \"POST\",\n+    body: JSON.stringify({ textQuery, maxResultCount }),\n+    fieldMask: \"places.id,places.displayName,places.formattedAddress,places.location,places.types\",\n   });\n-  const [plan, setPlan] = useState<{ items: PlanItem[]; destination: string; totalMinutes: number } | null>(null);\n-  const [error, setError] = useState<string | null>(null);\n-  const [loading, setLoading] = useState(false);\n \n-  const timeline = plan ? buildTimeline(plan.items as PlanItem[], startTime) : null;\n+  if (!res.ok) throw new Error(await res.text());\n+  const data = await res.json();\n+  return (data?.places ?? []) as any[];\n+}\n \n-  // Helper functions\n-  function formatPriceLevel(level?: string) {\n-    if (!level) return \"N/A\";\n-    const map: Record<string, string> = { cheap: \"$\", moderate: \"$$\", expensive: \"$$$\" };\n-    return map[level] || level;\n-  }\n+async function getPlaceDetails(key: string, placeId: string) {\n+  const url = `${PLACE_DETAILS_BASE}${encodeURIComponent(placeId)}`;\n+  const res = await googleFetch(url, {\n+    key,\n+    method: \"GET\",\n+    fieldMask:\n+      \"id,displayName,formattedAddress,location,rating,userRatingCount,priceLevel,regularOpeningHours,photos,reviews,googleMapsUri\",\n+  });\n+  if (!res.ok) throw new Error(await res.text());\n+  return (await res.json()) as any;\n+}\n \n-  function formatRating(rating?: number) {\n-    if (rating === undefined) return \"N/A\";\n-    return rating.toFixed(1);\n-  }\n+async function getPhotoUri(key: string, photoName: string, maxWidthPx = 900) {\n+  const url = `https://places.googleapis.com/v1/${photoName}/media?maxWidthPx=${maxWidthPx}&skipHttpRedirect=true`;\n+  const res = await googleFetch(url, { key, method: \"GET\", fieldMask: \"photoUri\" });\n+  if (!res.ok) return undefined;\n+  const data = await res.json();\n+  return data?.photoUri as string | undefined;\n+}\n \n-  function parseHHMMToDate(hhmm: string) {\n-    const [hhStr, mmStr] = (hhmm || \"\").split(\":\");\n-    const hh = Number(hhStr);\n-    const mm = Number(mmStr);\n-    const d = new Date();\n-    d.setSeconds(0, 0);\n-    d.setHours(Number.isFinite(hh) ? hh : d.getHours(), Number.isFinite(mm) ? mm : d.getMinutes(), 0, 0);\n-    return d;\n-  }\n+async function computeDriveMinutes(key: string, origin: LatLng, destination: LatLng) {\n+  const res = await googleFetch(ROUTES_COMPUTE, {\n+    key,\n+    method: \"POST\",\n+    body: JSON.stringify({\n+      origin: { location: { latLng: origin } },\n+      destination: { location: { latLng: destination } },\n+      travelMode: \"DRIVE\",\n+    }),\n+    fieldMask: \"routes.duration\",\n+  });\n \n-  function addMinutes(d: Date, minutes: number) {\n-    const out = new Date(d.getTime());\n-    out.setMinutes(out.getMinutes() + minutes);\n-    return out;\n-  }\n+  if (!res.ok) throw new Error(await res.text());\n+  const data = await res.json();\n+  const dur = data?.routes?.[0]?.duration ?? \"900s\";\n+  return toMinsFromDuration(dur);\n+}\n \n-  function formatTime(d: Date) {\n-    // 12-hour with AM/PM\n-    return d.toLocaleTimeString([], { hour: \"numeric\", minute: \"2-digit\" });\n-  }\n+async function findParkingNear(key: string, placeTitle: string, destinationLabel: string) {\n+  const q = `parking near ${placeTitle} ${destinationLabel}`;\n+  const results = await searchPlacesText(key, q, 5);\n+  const best = results?.[0];\n+  if (!best) return undefined;\n \n-  function buildTimeline(items: PlanItem[], startHHMM: string) {\n-    const start = parseHHMMToDate(startHHMM);\n-    let cursor = start;\n-    return items.map((it) => {\n-      const from = cursor;\n-      const to = addMinutes(cursor, Math.max(0, it.durationMin || 0));\n-      cursor = to;\n-      return { from, to };\n-    });\n-  }\n+  return {\n+    name: best?.displayName?.text ?? \"Parking\",\n+    address: best?.formattedAddress,\n+    // mapsUri is NOT available from places:searchText results\n+  } as ParkingOption;\n+}\n \n-  async function onQuickDemo() {\n-    setDestination(\"San Francisco\");\n-    setStyle(\"culture\");\n-    setDuration(150);\n-    setStartTime(\"14:00\");\n-    // ... other logic to generate demo plan\n+function pickStopCount(totalMinutes: number) {\n+  return totalMinutes <= 140 ? 2 : 3;\n+}\n+\n+function splitStopDurations(totalMinutes: number, travelTotal: number, stopCount: number) {\n+  const remaining = Math.max(60, totalMinutes - travelTotal);\n+  if (stopCount === 2) {\n+    const a = Math.floor(remaining * 0.55);\n+    return [a, remaining - a];\n   }\n+  const a = Math.floor(remaining * 0.42);\n+  const b = Math.floor(remaining * 0.35);\n+  return [a, b, remaining - a - b];\n+}\n \n-  return (\n-    <div>\n-      <div className=\"planner-card grid md:grid-cols-4 gap-4\">\n-        <div className=\"md:col-span-2\">\n-          <label className=\"text-xs text-white/60\">Destination</label>\n-          <input\n-            type=\"text\"\n-            value={destination}\n-            onChange={(e) => setDestination(e.target.value)}\n-            className=\"mt-1 w-full rounded-xl border border-white/15 bg-black/30 px-3 py-2 text-sm text-white outline-none transition focus:border-white/25\"\n-          />\n-        </div>\n-        <div>\n-          <label className=\"text-xs text-white/60\">Duration</label>\n-          <input\n-            type=\"number\"\n-            value={duration}\n-            onChange={(e) => setDuration(Number(e.target.value))}\n-            className=\"mt-1 w-full rounded-xl border border-white/15 bg-black/30 px-3 py-2 text-sm text-white outline-none transition focus:border-white/25\"\n-          />\n-        </div>\n-        <div>\n-          <label className=\"text-xs text-white/60\">Start time</label>\n-          <input\n-            type=\"time\"\n-            value={startTime}\n-            onChange={(e) => setStartTime(e.target.value)}\n-            className=\"mt-1 w-full rounded-xl border border-white/15 bg-black/30 px-3 py-2 text-sm text-white outline-none transition focus:border-white/25\"\n-          />\n-        </div>\n-      </div>\n+export async function POST(req: Request) {\n+  console.log(\"ðŸ”¥ /api/itinerary HIT (GOOGLE+DRIVE)\");\n \n-      {plan && (\n-        <div className=\"preview-header\">\n-          <h2>\n-            {plan.destination || \"â€”\"} â€¢ {plan.totalMinutes} min â€¢ {TRAVEL_STYLES.find((s) => s.key === style)?.label}\n-            {timeline && timeline.length ? (\n-              <span className=\"ml-2 text-white/55\">\n-                â€¢ {formatTime(timeline[0].from)}â€“{formatTime(timeline[timeline.length - 1].to)}\n-              </span>\n-            ) : null}\n-          </h2>\n-          <div className=\"plan-items\">\n-            {plan.items.map((it, idx) => (\n-              <div key={idx} className=\"plan-item-card\">\n-                <div className=\"flex items-center justify-between gap-3\">\n-                  <div className=\"flex items-center gap-2\">\n-                    <div className=\"text-sm font-semibold\">{it.type === \"stop\" ? \"Stop\" : \"Travel\"}</div>\n-                    {timeline?.[idx] ? (\n-                      <span className=\"rounded-full border border-white/15 bg-white/5 px-2 py-0.5 text-xs text-white/75\">\n-                        {formatTime(timeline[idx].from)}â€“{formatTime(timeline[idx].to)}\n-                      </span>\n-                    ) : null}\n-                  </div>\n-                  <div className=\"text-xs text-white/55\">{it.durationMin} min</div>\n-                </div>\n-                {/* Additional item details here */}\n-              </div>\n-            ))}\n-          </div>\n-        </div>\n-      )}\n-    </div>\n-  );\n+  try {\n+    const body = await req.json().catch(() => ({}));\n+\n+    const destination = String(body?.destination ?? \"\").trim();\n+    const totalMinutes = clamp(Number(body?.totalMinutes ?? 150), 120, 180);\n+    const vibe = String(body?.vibe ?? \"culture\");\n+\n+    if (!destination) {\n+      return NextResponse.json({ error: \"Destination is required\" }, { status: 400 });\n+    }\n+\n+    const key = process.env.GOOGLE_MAPS_API_KEY;\n+    if (!key) {\n+      return NextResponse.json(\n+        { error: \"Missing GOOGLE_MAPS_API_KEY. Add it to .env.local and restart npm run dev.\" },\n+        { status: 500 }\n+      );\n+    }\n+\n+    const query =\n+      vibe === \"adventure\"\n+        ? `top viewpoints parks trails in ${destination}`\n+        : vibe === \"foodie\"\n+        ? `best cafes restaurants bakeries in ${destination}`\n+        : vibe === \"relaxed\"\n+        ? `waterfront parks cafes in ${destination}`\n+        : `top tourist attractions museums in ${destination}`;\n+\n+    const candidates = await searchPlacesText(key, query, 12);\n+    if (candidates.length < 2) {\n+      return NextResponse.json({ error: \"Not enough places found\" }, { status: 404 });\n+    }\n+\n+    const stopCount = pickStopCount(totalMinutes);\n+    const chosen = candidates.slice(0, stopCount);\n+\n+    const stops: StopDetails[] = await Promise.all(\n+      chosen.map(async (p) => {\n+        const placeId = String(p?.id ?? \"\");\n+        if (!placeId) throw new Error(\"Google Places returned an item without id\");\n+\n+        const details = await getPlaceDetails(key, placeId);\n+\n+        let photoUrl: string | undefined;\n+        const firstPhotoName = details?.photos?.[0]?.name;\n+        if (firstPhotoName) {\n+          photoUrl = await getPhotoUri(key, firstPhotoName, 1000);\n+        }\n+\n+        const reviewSnippet = safeText(details?.reviews?.[0]?.text?.text, 170);\n+\n+        const openNow = details?.regularOpeningHours?.openNow;\n+        const weekdayText = Array.isArray(details?.regularOpeningHours?.weekdayDescriptions)\n+          ? (details.regularOpeningHours.weekdayDescriptions as string[])\n+          : undefined;\n+\n+        let parking: ParkingOption | undefined;\n+        try {\n+          parking = await findParkingNear(key, details?.displayName?.text ?? \"\", destination);\n+        } catch {\n+          parking = undefined;\n+        }\n+\n+        return {\n+          placeId,\n+          title: details?.displayName?.text ?? \"Place\",\n+          address: details?.formattedAddress,\n+          lat: Number(details?.location?.latitude),\n+          lng: Number(details?.location?.longitude),\n+          mapsUri: details?.googleMapsUri,\n+\n+          rating: typeof details?.rating === \"number\" ? details.rating : undefined,\n+          userRatingCount:\n+            typeof details?.userRatingCount === \"number\" ? details.userRatingCount : undefined,\n+          priceLevel: typeof details?.priceLevel === \"string\" ? details.priceLevel : undefined,\n+          openNow: typeof openNow === \"boolean\" ? openNow : undefined,\n+          weekdayText,\n+          photoUrl,\n+          reviewSnippet,\n+          parking,\n+        };\n+      })\n+    );\n+\n+    const travelMins: number[] = [];\n+    for (let i = 0; i < stops.length - 1; i++) {\n+      const a = stops[i];\n+      const b = stops[i + 1];\n+      const mins = await computeDriveMinutes(\n+        key,\n+        { latitude: a.lat, longitude: a.lng },\n+        { latitude: b.lat, longitude: b.lng }\n+      );\n+      travelMins.push(mins);\n+    }\n+\n+    const travelTotal = travelMins.reduce((x, y) => x + y, 0);\n+    const stopDurations = splitStopDurations(totalMinutes, travelTotal, stops.length);\n+\n+    const items: PlanItem[] = [];\n+    for (let i = 0; i < stops.length; i++) {\n+      items.push({ type: \"stop\", durationMin: Math.max(25, stopDurations[i] ?? 40), ...stops[i] });\n+      if (i < travelMins.length) {\n+        items.push({ type: \"travel\", title: \"Drive to next stop\", durationMin: travelMins[i], mode: \"DRIVE\" });\n+      }\n+    }\n+\n+    return NextResponse.json({\n+      destination,\n+      totalMinutes,\n+      vibe,\n+      source: \"google\",\n+      items,\n+    });\n+  } catch (e) {\n+    const msg = e instanceof Error ? e.message : \"Failed to generate itinerary\";\n+    return NextResponse.json({ error: msg }, { status: 500 });\n+  }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1766865494813,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,10 +9,13 @@\n \n type LatLng = { latitude: number; longitude: number };\n \n type ParkingOption = {\n+  placeId?: string;\n   name: string;\n   address?: string;\n+  lat?: number;\n+  lng?: number;\n   mapsUri?: string;\n };\n \n type StopDetails = {\n@@ -34,16 +37,17 @@\n };\n \n type PlanItem =\n   | ({ type: \"stop\"; durationMin: number } & StopDetails)\n-  | { type: \"travel\"; title: string; durationMin: number; mode: \"DRIVE\" };\n+  | { type: \"travel\"; title: string; durationMin: number; mode: \"DRIVE\" | \"WALK\" };\n \n function clamp(n: number, min: number, max: number) {\n   if (!Number.isFinite(n)) return min;\n   return Math.max(min, Math.min(max, n));\n }\n \n function toMinsFromDuration(durationStr: string): number {\n+  // e.g. \"1234s\"\n   const secs = Number(String(durationStr ?? \"\").replace(\"s\", \"\")) || 900;\n   return Math.max(5, Math.round(secs / 60));\n }\n \n@@ -59,9 +63,11 @@\n     \"Content-Type\": \"application/json\",\n     \"X-Goog-Api-Key\": key,\n     ...(rest.headers as Record<string, string> | undefined),\n   };\n+  // Places API (New) requires FieldMask for response fields\n   if (fieldMask) headers[\"X-Goog-FieldMask\"] = fieldMask;\n+\n   return fetch(url, { ...rest, headers });\n }\n \n async function searchPlacesText(key: string, textQuery: string, maxResultCount = 10) {\n@@ -89,23 +95,29 @@\n   return (await res.json()) as any;\n }\n \n async function getPhotoUri(key: string, photoName: string, maxWidthPx = 900) {\n+  // /v1/{name}/media?maxWidthPx=...&skipHttpRedirect=true\n   const url = `https://places.googleapis.com/v1/${photoName}/media?maxWidthPx=${maxWidthPx}&skipHttpRedirect=true`;\n   const res = await googleFetch(url, { key, method: \"GET\", fieldMask: \"photoUri\" });\n   if (!res.ok) return undefined;\n   const data = await res.json();\n   return data?.photoUri as string | undefined;\n }\n \n-async function computeDriveMinutes(key: string, origin: LatLng, destination: LatLng) {\n+async function computeRouteMinutes(\n+  key: string,\n+  origin: LatLng,\n+  destination: LatLng,\n+  travelMode: \"DRIVE\" | \"WALK\"\n+) {\n   const res = await googleFetch(ROUTES_COMPUTE, {\n     key,\n     method: \"POST\",\n     body: JSON.stringify({\n       origin: { location: { latLng: origin } },\n       destination: { location: { latLng: destination } },\n-      travelMode: \"DRIVE\",\n+      travelMode,\n     }),\n     fieldMask: \"routes.duration\",\n   });\n \n@@ -120,15 +132,33 @@\n   const results = await searchPlacesText(key, q, 5);\n   const best = results?.[0];\n   if (!best) return undefined;\n \n+  const loc = best?.location;\n+\n   return {\n+    placeId: best?.id,\n     name: best?.displayName?.text ?? \"Parking\",\n     address: best?.formattedAddress,\n+    lat: typeof loc?.latitude === \"number\" ? loc.latitude : undefined,\n+    lng: typeof loc?.longitude === \"number\" ? loc.longitude : undefined,\n     // mapsUri is NOT available from places:searchText results\n   } as ParkingOption;\n }\n \n+async function enrichParkingMapsUri(key: string, parking?: ParkingOption) {\n+  if (!parking?.placeId) return parking;\n+  try {\n+    const details = await getPlaceDetails(key, parking.placeId);\n+    return {\n+      ...parking,\n+      mapsUri: details?.googleMapsUri,\n+    } as ParkingOption;\n+  } catch {\n+    return parking;\n+  }\n+}\n+\n function pickStopCount(totalMinutes: number) {\n   return totalMinutes <= 140 ? 2 : 3;\n }\n \n@@ -151,8 +181,9 @@\n \n     const destination = String(body?.destination ?? \"\").trim();\n     const totalMinutes = clamp(Number(body?.totalMinutes ?? 150), 120, 180);\n     const vibe = String(body?.vibe ?? \"culture\");\n+    const parkOnce = Boolean(body?.parkOnce);\n \n     if (!destination) {\n       return NextResponse.json({ error: \"Destination is required\" }, { status: 400 });\n     }\n@@ -188,24 +219,29 @@\n         if (!placeId) throw new Error(\"Google Places returned an item without id\");\n \n         const details = await getPlaceDetails(key, placeId);\n \n+        // Photo\n         let photoUrl: string | undefined;\n         const firstPhotoName = details?.photos?.[0]?.name;\n         if (firstPhotoName) {\n           photoUrl = await getPhotoUri(key, firstPhotoName, 1000);\n         }\n \n+        // Reviews\n         const reviewSnippet = safeText(details?.reviews?.[0]?.text?.text, 170);\n \n+        // Opening hours\n         const openNow = details?.regularOpeningHours?.openNow;\n         const weekdayText = Array.isArray(details?.regularOpeningHours?.weekdayDescriptions)\n           ? (details.regularOpeningHours.weekdayDescriptions as string[])\n           : undefined;\n \n+        // Parking near each stop (best effort)\n         let parking: ParkingOption | undefined;\n         try {\n-          parking = await findParkingNear(key, details?.displayName?.text ?? \"\", destination);\n+          const base = await findParkingNear(key, details?.displayName?.text ?? \"\", destination);\n+          parking = await enrichParkingMapsUri(key, base);\n         } catch {\n           parking = undefined;\n         }\n \n@@ -229,35 +265,133 @@\n         };\n       })\n     );\n \n+    // Optional: Park once near first stop, then walk between stops\n+    let parkOnceLocation: ParkingOption | undefined;\n+    if (parkOnce && stops.length > 0) {\n+      try {\n+        const base = await findParkingNear(key, stops[0].title, destination);\n+        parkOnceLocation = await enrichParkingMapsUri(key, base);\n+      } catch {\n+        parkOnceLocation = undefined;\n+      }\n+    }\n+\n     const travelMins: number[] = [];\n-    for (let i = 0; i < stops.length - 1; i++) {\n-      const a = stops[i];\n-      const b = stops[i + 1];\n-      const mins = await computeDriveMinutes(\n+\n+    // If parkOnce, add a first travel leg from parking -> first stop (WALK) and then walk between stops.\n+    if (parkOnce && parkOnceLocation?.lat != null && parkOnceLocation?.lng != null && stops.length > 0) {\n+      const firstStop = stops[0];\n+      const fromParkingToFirst = await computeRouteMinutes(\n         key,\n-        { latitude: a.lat, longitude: a.lng },\n-        { latitude: b.lat, longitude: b.lng }\n+        { latitude: parkOnceLocation.lat, longitude: parkOnceLocation.lng },\n+        { latitude: firstStop.lat, longitude: firstStop.lng },\n+        \"WALK\"\n       );\n-      travelMins.push(mins);\n+      travelMins.push(fromParkingToFirst);\n+\n+      for (let i = 0; i < stops.length - 1; i++) {\n+        const a = stops[i];\n+        const b = stops[i + 1];\n+        const mins = await computeRouteMinutes(\n+          key,\n+          { latitude: a.lat, longitude: a.lng },\n+          { latitude: b.lat, longitude: b.lng },\n+          \"WALK\"\n+        );\n+        travelMins.push(mins);\n+      }\n+    } else {\n+      // Default: DRIVE between stops\n+      for (let i = 0; i < stops.length - 1; i++) {\n+        const a = stops[i];\n+        const b = stops[i + 1];\n+        const mins = await computeRouteMinutes(\n+          key,\n+          { latitude: a.lat, longitude: a.lng },\n+          { latitude: b.lat, longitude: b.lng },\n+          \"DRIVE\"\n+        );\n+        travelMins.push(mins);\n+      }\n     }\n \n     const travelTotal = travelMins.reduce((x, y) => x + y, 0);\n     const stopDurations = splitStopDurations(totalMinutes, travelTotal, stops.length);\n \n     const items: PlanItem[] = [];\n-    for (let i = 0; i < stops.length; i++) {\n-      items.push({ type: \"stop\", durationMin: Math.max(25, stopDurations[i] ?? 40), ...stops[i] });\n-      if (i < travelMins.length) {\n-        items.push({ type: \"travel\", title: \"Drive to next stop\", durationMin: travelMins[i], mode: \"DRIVE\" });\n+\n+    if (parkOnce && parkOnceLocation?.lat != null && parkOnceLocation?.lng != null) {\n+      // Add a parking stop card first (5 min buffer)\n+      items.push({\n+        type: \"stop\",\n+        durationMin: 5,\n+        placeId: parkOnceLocation.placeId || \"parking\",\n+        title: \"Park once\",\n+        address: parkOnceLocation.address,\n+        lat: parkOnceLocation.lat,\n+        lng: parkOnceLocation.lng,\n+        mapsUri: parkOnceLocation.mapsUri,\n+        rating: undefined,\n+        userRatingCount: undefined,\n+        priceLevel: undefined,\n+        openNow: undefined,\n+        weekdayText: undefined,\n+        photoUrl: undefined,\n+        reviewSnippet: undefined,\n+        parking: {\n+          placeId: parkOnceLocation.placeId,\n+          name: parkOnceLocation.name,\n+          address: parkOnceLocation.address,\n+          lat: parkOnceLocation.lat,\n+          lng: parkOnceLocation.lng,\n+          mapsUri: parkOnceLocation.mapsUri,\n+        },\n+      });\n+\n+      // Travel leg from parking -> first stop (WALK) is travelMins[0]\n+      if (travelMins.length > 0) {\n+        items.push({\n+          type: \"travel\",\n+          title: \"Walk to first stop\",\n+          durationMin: travelMins[0],\n+          mode: \"WALK\",\n+        });\n       }\n+\n+      for (let i = 0; i < stops.length; i++) {\n+        items.push({ type: \"stop\", durationMin: Math.max(25, stopDurations[i] ?? 40), ...stops[i] });\n+        if (i < stops.length - 1) {\n+          const leg = travelMins[i + 1] ?? 10;\n+          items.push({\n+            type: \"travel\",\n+            title: \"Walk to next stop\",\n+            durationMin: leg,\n+            mode: \"WALK\",\n+          });\n+        }\n+      }\n+    } else {\n+      // Default DRIVE itinerary\n+      for (let i = 0; i < stops.length; i++) {\n+        items.push({ type: \"stop\", durationMin: Math.max(25, stopDurations[i] ?? 40), ...stops[i] });\n+        if (i < travelMins.length) {\n+          items.push({\n+            type: \"travel\",\n+            title: \"Drive to next stop\",\n+            durationMin: travelMins[i],\n+            mode: \"DRIVE\",\n+          });\n+        }\n+      }\n     }\n \n     return NextResponse.json({\n       destination,\n       totalMinutes,\n       vibe,\n+      parkOnce,\n       source: \"google\",\n       items,\n     });\n   } catch (e) {\n"
                },
                {
                    "date": 1766867845511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,153 @@\n   if (!t) return undefined;\n   return t.length > maxLen ? `${t.slice(0, maxLen - 1)}â€¦` : t;\n }\n \n+function haversineKm(\n+  a: { latitude: number; longitude: number },\n+  b: { latitude: number; longitude: number }\n+) {\n+  const R = 6371;\n+  const dLat = ((b.latitude - a.latitude) * Math.PI) / 180;\n+  const dLon = ((b.longitude - a.longitude) * Math.PI) / 180;\n+  const lat1 = (a.latitude * Math.PI) / 180;\n+  const lat2 = (b.latitude * Math.PI) / 180;\n+  const sin1 = Math.sin(dLat / 2);\n+  const sin2 = Math.sin(dLon / 2);\n+  const h = sin1 * sin1 + Math.cos(lat1) * Math.cos(lat2) * sin2 * sin2;\n+  return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));\n+}\n+\n+function pickCategory(types: any): \"food\" | \"park\" | \"attraction\" {\n+  const t = Array.isArray(types) ? (types as string[]) : [];\n+  const has = (k: string) => t.includes(k);\n+\n+  // Food / coffee\n+  if (\n+    has(\"restaurant\") ||\n+    has(\"cafe\") ||\n+    has(\"bakery\") ||\n+    has(\"bar\") ||\n+    has(\"meal_takeaway\") ||\n+    has(\"meal_delivery\")\n+  ) {\n+    return \"food\";\n+  }\n+\n+  // Parks / outdoor\n+  if (\n+    has(\"park\") ||\n+    has(\"natural_feature\") ||\n+    has(\"campground\") ||\n+    has(\"rv_park\") ||\n+    has(\"hiking_area\")\n+  ) {\n+    return \"park\";\n+  }\n+\n+  return \"attraction\";\n+}\n+\n+function isNoisyType(types: any) {\n+  const t = Array.isArray(types) ? (types as string[]) : [];\n+  const bad = new Set([\n+    \"accounting\",\n+    \"atm\",\n+    \"bank\",\n+    \"car_dealer\",\n+    \"car_rental\",\n+    \"car_repair\",\n+    \"car_wash\",\n+    \"courthouse\",\n+    \"dentist\",\n+    \"doctor\",\n+    \"electrician\",\n+    \"finance\",\n+    \"gas_station\",\n+    \"insurance_agency\",\n+    \"lawyer\",\n+    \"local_government_office\",\n+    \"moving_company\",\n+    \"painter\",\n+    \"pharmacy\",\n+    \"plumber\",\n+    \"police\",\n+    \"post_office\",\n+    \"real_estate_agency\",\n+    \"school\",\n+    \"storage\",\n+    \"transit_station\",\n+    \"vehicle_inspection\",\n+    \"hospital\",\n+  ]);\n+\n+  // If it contains ONLY bad types, reject.\n+  const nonBad = t.filter((x) => !bad.has(x));\n+  if (nonBad.length === 0 && t.length > 0) return true;\n+\n+  // Otherwise allow if it has useful categories.\n+  return false;\n+}\n+\n+function scoreCandidate(p: any) {\n+  const rating = typeof p?.rating === \"number\" ? p.rating : 0;\n+  const count = typeof p?.userRatingCount === \"number\" ? p.userRatingCount : 0;\n+\n+  // Prefer well-rated, well-reviewed places.\n+  const score = rating * 12 + Math.log10(Math.max(1, count)) * 8;\n+\n+  // Small category boosts\n+  const cat = pickCategory(p?.types);\n+  const boost = cat === \"attraction\" ? 1.12 : cat === \"park\" ? 1.08 : 1.0;\n+\n+  return score * boost;\n+}\n+\n+function desiredCategories(vibe: string, stopCount: number): (\"attraction\" | \"food\" | \"park\")[] {\n+  // 2 stops: always include an anchor + a food/coffee stop\n+  if (stopCount === 2) return vibe === \"foodie\" ? [\"food\", \"attraction\"] : [\"attraction\", \"food\"];\n+\n+  // 3 stops: vary the order by vibe\n+  if (vibe === \"adventure\") return [\"park\", \"attraction\", \"food\"];\n+  if (vibe === \"relaxed\") return [\"park\", \"food\", \"attraction\"];\n+  if (vibe === \"foodie\") return [\"food\", \"attraction\", \"park\"];\n+  return [\"attraction\", \"food\", \"park\"]; // culture/default\n+}\n+\n+function orderByNearestNeighbor(list: any[]) {\n+  if (list.length <= 2) return list;\n+  const remaining = [...list];\n+  const ordered: any[] = [];\n+\n+  // Start with the best-scoring item.\n+  remaining.sort((a, b) => scoreCandidate(b) - scoreCandidate(a));\n+  ordered.push(remaining.shift());\n+\n+  while (remaining.length > 0) {\n+    const last = ordered[ordered.length - 1];\n+    const lastLoc = last?.location;\n+    if (!lastLoc) {\n+      ordered.push(remaining.shift());\n+      continue;\n+    }\n+\n+    let bestIdx = 0;\n+    let bestD = Number.POSITIVE_INFINITY;\n+    for (let i = 0; i < remaining.length; i++) {\n+      const loc = remaining[i]?.location;\n+      if (!loc) continue;\n+      const d = haversineKm(lastLoc, loc);\n+      if (d < bestD) {\n+        bestD = d;\n+        bestIdx = i;\n+      }\n+    }\n+    ordered.push(remaining.splice(bestIdx, 1)[0]);\n+  }\n+\n+  return ordered.filter(Boolean);\n+}\n+\n async function googleFetch(url: string, opts: RequestInit & { fieldMask?: string; key: string }) {\n   const { fieldMask, key, ...rest } = opts;\n   const headers: Record<string, string> = {\n     \"Content-Type\": \"application/json\",\n@@ -74,9 +219,9 @@\n   const res = await googleFetch(PLACES_SEARCH_TEXT, {\n     key,\n     method: \"POST\",\n     body: JSON.stringify({ textQuery, maxResultCount }),\n-    fieldMask: \"places.id,places.displayName,places.formattedAddress,places.location,places.types\",\n+    fieldMask: \"places.id,places.displayName,places.formattedAddress,places.location,places.types,places.rating,places.userRatingCount\",\n   });\n \n   if (!res.ok) throw new Error(await res.text());\n   const data = await res.json();\n@@ -204,16 +349,84 @@\n         : vibe === \"relaxed\"\n         ? `waterfront parks cafes in ${destination}`\n         : `top tourist attractions museums in ${destination}`;\n \n-    const candidates = await searchPlacesText(key, query, 12);\n-    if (candidates.length < 2) {\n-      return NextResponse.json({ error: \"Not enough places found\" }, { status: 404 });\n+    // Get a reasonable \"center\" for the destination (first result is usually the city/area).\n+    const destPlaces = await searchPlacesText(key, destination, 3);\n+    const destCenter = destPlaces?.[0]?.location as { latitude: number; longitude: number } | undefined;\n+\n+    // Pull a larger pool so we can filter and pick better stops.\n+    // Use multiple queries to increase variety.\n+    const qAttraction = `top attractions museums landmarks in ${destination}`;\n+    const qFood = `best cafes restaurants bakeries in ${destination}`;\n+    const qPark = `best parks viewpoints waterfront in ${destination}`;\n+\n+    const [candA, candF, candP, candVibe] = await Promise.all([\n+      searchPlacesText(key, qAttraction, 20),\n+      searchPlacesText(key, qFood, 20),\n+      searchPlacesText(key, qPark, 20),\n+      searchPlacesText(key, query, 20),\n+    ]);\n+\n+    // Deduplicate by place id\n+    const byId = new Map<string, any>();\n+    for (const p of [...candA, ...candF, ...candP, ...candVibe]) {\n+      if (p?.id && !byId.has(p.id)) byId.set(p.id, p);\n     }\n+    const pooled = Array.from(byId.values());\n \n     const stopCount = pickStopCount(totalMinutes);\n-    const chosen = candidates.slice(0, stopCount);\n \n+    const radiusKm = 10; // keeps results local for city/area searches\n+\n+    const filtered = pooled\n+      .filter((p) => p?.id && p?.location?.latitude != null && p?.location?.longitude != null)\n+      .filter((p) => !isNoisyType(p?.types))\n+      .filter((p) => {\n+        const rating = typeof p?.rating === \"number\" ? p.rating : 0;\n+        const count = typeof p?.userRatingCount === \"number\" ? p.userRatingCount : 0;\n+\n+        // baseline quality: if it has reviews, enforce a decent rating\n+        if (count >= 20 && rating > 0 && rating < 4.1) return false;\n+        if (count >= 5 && rating > 0 && rating < 3.9) return false;\n+\n+        if (destCenter) {\n+          const km = haversineKm(destCenter, p.location);\n+          if (km > radiusKm) return false;\n+        }\n+        return true;\n+      })\n+      .sort((a, b) => scoreCandidate(b) - scoreCandidate(a));\n+\n+    if (filtered.length < 2) {\n+      return NextResponse.json({ error: \"Not enough high-quality places found\" }, { status: 404 });\n+    }\n+\n+    // Diversity selection: attraction + food + park (order varies by vibe)\n+    const want = desiredCategories(vibe, stopCount);\n+    const picked: any[] = [];\n+\n+    for (const cat of want) {\n+      const next = filtered.find(\n+        (p) => pickCategory(p?.types) === cat && !picked.some((x) => x.id === p.id)\n+      );\n+      if (next) picked.push(next);\n+    }\n+\n+    // Fill remaining from top-ranked items\n+    while (picked.length < stopCount) {\n+      const next = filtered.find((p) => !picked.some((x) => x.id === p.id));\n+      if (!next) break;\n+      picked.push(next);\n+    }\n+\n+    // Simple ordering to reduce travel time\n+    const chosen = orderByNearestNeighbor(picked).slice(0, stopCount);\n+\n+    if (chosen.length < 2) {\n+      return NextResponse.json({ error: \"Not enough places found after filtering\" }, { status: 404 });\n+    }\n+\n     const stops: StopDetails[] = await Promise.all(\n       chosen.map(async (p) => {\n         const placeId = String(p?.id ?? \"\");\n         if (!placeId) throw new Error(\"Google Places returned an item without id\");\n"
                },
                {
                    "date": 1766870299851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -138,13 +138,12 @@\n   // If it contains ONLY bad types, reject.\n   const nonBad = t.filter((x) => !bad.has(x));\n   if (nonBad.length === 0 && t.length > 0) return true;\n \n-  // Otherwise allow if it has useful categories.\n   return false;\n }\n \n-function scoreCandidate(p: any) {\n+function scoreCandidate(p: any, riderMode?: boolean) {\n   const rating = typeof p?.rating === \"number\" ? p.rating : 0;\n   const count = typeof p?.userRatingCount === \"number\" ? p.userRatingCount : 0;\n \n   // Prefer well-rated, well-reviewed places.\n@@ -153,8 +152,28 @@\n   // Small category boosts\n   const cat = pickCategory(p?.types);\n   const boost = cat === \"attraction\" ? 1.12 : cat === \"park\" ? 1.08 : 1.0;\n \n+  // Rider Mode: boost scenic/outdoors + one good food/coffee stop\n+  if (riderMode) {\n+    const t = Array.isArray(p?.types) ? (p.types as string[]) : [];\n+    const scenicBoostTypes = new Set([\n+      \"tourist_attraction\",\n+      \"park\",\n+      \"natural_feature\",\n+      \"viewpoint\",\n+      \"scenic_lookout\",\n+      \"hiking_area\",\n+      \"campground\",\n+    ]);\n+\n+    const isScenic = t.some((x) => scenicBoostTypes.has(x));\n+    const hasFood = t.includes(\"cafe\") || t.includes(\"restaurant\") || t.includes(\"bakery\");\n+\n+    if (isScenic) return score * boost * 1.18;\n+    if (hasFood) return score * boost * 1.08;\n+  }\n+\n   return score * boost;\n }\n \n function desiredCategories(vibe: string, stopCount: number): (\"attraction\" | \"food\" | \"park\")[] {\n@@ -167,15 +186,15 @@\n   if (vibe === \"foodie\") return [\"food\", \"attraction\", \"park\"];\n   return [\"attraction\", \"food\", \"park\"]; // culture/default\n }\n \n-function orderByNearestNeighbor(list: any[]) {\n+function orderByNearestNeighbor(list: any[], riderMode?: boolean) {\n   if (list.length <= 2) return list;\n   const remaining = [...list];\n   const ordered: any[] = [];\n \n   // Start with the best-scoring item.\n-  remaining.sort((a, b) => scoreCandidate(b) - scoreCandidate(a));\n+  remaining.sort((a, b) => scoreCandidate(b, riderMode) - scoreCandidate(a, riderMode));\n   ordered.push(remaining.shift());\n \n   while (remaining.length > 0) {\n     const last = ordered[ordered.length - 1];\n@@ -219,9 +238,10 @@\n   const res = await googleFetch(PLACES_SEARCH_TEXT, {\n     key,\n     method: \"POST\",\n     body: JSON.stringify({ textQuery, maxResultCount }),\n-    fieldMask: \"places.id,places.displayName,places.formattedAddress,places.location,places.types,places.rating,places.userRatingCount\",\n+    fieldMask:\n+      \"places.id,places.displayName,places.formattedAddress,places.location,places.types,places.rating,places.userRatingCount\",\n   });\n \n   if (!res.ok) throw new Error(await res.text());\n   const data = await res.json();\n@@ -327,8 +347,9 @@\n     const destination = String(body?.destination ?? \"\").trim();\n     const totalMinutes = clamp(Number(body?.totalMinutes ?? 150), 120, 180);\n     const vibe = String(body?.vibe ?? \"culture\");\n     const parkOnce = Boolean(body?.parkOnce);\n+    const riderMode = Boolean(body?.riderMode);\n \n     if (!destination) {\n       return NextResponse.json({ error: \"Destination is required\" }, { status: 400 });\n     }\n@@ -358,25 +379,28 @@\n     // Use multiple queries to increase variety.\n     const qAttraction = `top attractions museums landmarks in ${destination}`;\n     const qFood = `best cafes restaurants bakeries in ${destination}`;\n     const qPark = `best parks viewpoints waterfront in ${destination}`;\n+    const qScenic = `scenic viewpoints waterfront drives in ${destination}`;\n+    const qRideCoffee = `coffee stops with parking in ${destination}`;\n \n-    const [candA, candF, candP, candVibe] = await Promise.all([\n+    const [candA, candF, candP, candVibe, candScenic, candRideCoffee] = await Promise.all([\n       searchPlacesText(key, qAttraction, 20),\n       searchPlacesText(key, qFood, 20),\n       searchPlacesText(key, qPark, 20),\n       searchPlacesText(key, query, 20),\n+      searchPlacesText(key, riderMode ? qScenic : qAttraction, 20),\n+      searchPlacesText(key, riderMode ? qRideCoffee : qFood, 20),\n     ]);\n \n     // Deduplicate by place id\n     const byId = new Map<string, any>();\n-    for (const p of [...candA, ...candF, ...candP, ...candVibe]) {\n+    for (const p of [...candA, ...candF, ...candP, ...candVibe, ...candScenic, ...candRideCoffee]) {\n       if (p?.id && !byId.has(p.id)) byId.set(p.id, p);\n     }\n     const pooled = Array.from(byId.values());\n \n     const stopCount = pickStopCount(totalMinutes);\n-\n     const radiusKm = 10; // keeps results local for city/area searches\n \n     const filtered = pooled\n       .filter((p) => p?.id && p?.location?.latitude != null && p?.location?.longitude != null)\n@@ -394,34 +418,96 @@\n           if (km > radiusKm) return false;\n         }\n         return true;\n       })\n-      .sort((a, b) => scoreCandidate(b) - scoreCandidate(a));\n+      .sort((a, b) => scoreCandidate(b, riderMode) - scoreCandidate(a, riderMode));\n \n     if (filtered.length < 2) {\n       return NextResponse.json({ error: \"Not enough high-quality places found\" }, { status: 404 });\n     }\n \n     // Diversity selection: attraction + food + park (order varies by vibe)\n     const want = desiredCategories(vibe, stopCount);\n+\n+    // If Park Once is enabled, prefer a tight cluster around the first (anchor) stop.\n+    // For walkable clusters, ~1.5km is a good starting point; relax to 3km if needed.\n+    const walkKmPrimary = 1.5;\n+    const walkKmRelaxed = 3;\n+\n     const picked: any[] = [];\n \n-    for (const cat of want) {\n-      const next = filtered.find(\n-        (p) => pickCategory(p?.types) === cat && !picked.some((x) => x.id === p.id)\n-      );\n+    // 1) Pick an anchor (first desired category) from overall filtered pool.\n+    const anchorCat = want[0];\n+    const anchor = filtered.find((p) => pickCategory(p?.types) === anchorCat) || filtered[0];\n+    if (anchor) picked.push(anchor);\n+\n+    const anchorLoc = anchor?.location as { latitude: number; longitude: number } | undefined;\n+\n+    // 2) Build a pool for subsequent picks.\n+    const poolPrimary =\n+      parkOnce && anchorLoc\n+        ? filtered.filter((p) => {\n+            const loc = p?.location as { latitude: number; longitude: number } | undefined;\n+            if (!loc) return false;\n+            return haversineKm(anchorLoc, loc) <= walkKmPrimary;\n+          })\n+        : filtered;\n+\n+    const poolRelaxed =\n+      parkOnce && anchorLoc\n+        ? filtered.filter((p) => {\n+            const loc = p?.location as { latitude: number; longitude: number } | undefined;\n+            if (!loc) return false;\n+            return haversineKm(anchorLoc, loc) <= walkKmRelaxed;\n+          })\n+        : filtered;\n+\n+    const pickFromPool = (pool: any[], cat: \"attraction\" | \"food\" | \"park\") =>\n+      pool.find((p) => pickCategory(p?.types) === cat && !picked.some((x) => x.id === p.id));\n+\n+    // 3) Fill remaining desired categories, preferring the tight pool.\n+    for (const cat of want.slice(1)) {\n+      let next = pickFromPool(poolPrimary, cat);\n+      if (!next) next = pickFromPool(poolRelaxed, cat);\n+      if (!next) next = pickFromPool(filtered, cat);\n       if (next) picked.push(next);\n     }\n \n-    // Fill remaining from top-ranked items\n-    while (picked.length < stopCount) {\n-      const next = filtered.find((p) => !picked.some((x) => x.id === p.id));\n-      if (!next) break;\n-      picked.push(next);\n+    // 4) If still short, fill from tight pool first, then relaxed, then overall.\n+    const fillFrom = (pool: any[]) => {\n+      while (picked.length < stopCount) {\n+        const next = pool.find((p) => !picked.some((x) => x.id === p.id));\n+        if (!next) break;\n+        picked.push(next);\n+      }\n+    };\n+\n+    fillFrom(poolPrimary);\n+    fillFrom(poolRelaxed);\n+    fillFrom(filtered);\n+\n+    // Ordering:\n+    // - If Park Once: keep the anchor first then order rest by nearest-neighbor for minimal walking.\n+    // - Else: nearest-neighbor for minimal driving.\n+    let ordered = parkOnce\n+      ? [picked[0], ...orderByNearestNeighbor(picked.slice(1), riderMode)]\n+      : orderByNearestNeighbor(picked, riderMode);\n+\n+    // Rider mode: prefer a loose loop by ending near the anchor.\n+    if (riderMode && ordered.length >= 3 && anchorLoc) {\n+      const rest = ordered.slice(1);\n+      rest.sort((a, b) => {\n+        const la = a?.location as any;\n+        const lb = b?.location as any;\n+        if (!la || !lb) return 0;\n+        const da = haversineKm(anchorLoc, la);\n+        const db = haversineKm(anchorLoc, lb);\n+        return da - db;\n+      });\n+      ordered = [ordered[0], ...rest];\n     }\n \n-    // Simple ordering to reduce travel time\n-    const chosen = orderByNearestNeighbor(picked).slice(0, stopCount);\n+    const chosen = ordered.filter(Boolean).slice(0, stopCount);\n \n     if (chosen.length < 2) {\n       return NextResponse.json({ error: \"Not enough places found after filtering\" }, { status: 404 });\n     }\n@@ -603,8 +689,9 @@\n       destination,\n       totalMinutes,\n       vibe,\n       parkOnce,\n+      riderMode,\n       source: \"google\",\n       items,\n     });\n   } catch (e) {\n"
                },
                {
                    "date": 1766870819344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,8 @@\n   return Math.max(min, Math.min(max, n));\n }\n \n function toMinsFromDuration(durationStr: string): number {\n-  // e.g. \"1234s\"\n   const secs = Number(String(durationStr ?? \"\").replace(\"s\", \"\")) || 900;\n   return Math.max(5, Math.round(secs / 60));\n }\n \n@@ -75,9 +74,8 @@\n function pickCategory(types: any): \"food\" | \"park\" | \"attraction\" {\n   const t = Array.isArray(types) ? (types as string[]) : [];\n   const has = (k: string) => t.includes(k);\n \n-  // Food / coffee\n   if (\n     has(\"restaurant\") ||\n     has(\"cafe\") ||\n     has(\"bakery\") ||\n@@ -87,9 +85,8 @@\n   ) {\n     return \"food\";\n   }\n \n-  // Parks / outdoor\n   if (\n     has(\"park\") ||\n     has(\"natural_feature\") ||\n     has(\"campground\") ||\n@@ -134,9 +131,8 @@\n     \"vehicle_inspection\",\n     \"hospital\",\n   ]);\n \n-  // If it contains ONLY bad types, reject.\n   const nonBad = t.filter((x) => !bad.has(x));\n   if (nonBad.length === 0 && t.length > 0) return true;\n \n   return false;\n@@ -145,16 +141,13 @@\n function scoreCandidate(p: any, riderMode?: boolean) {\n   const rating = typeof p?.rating === \"number\" ? p.rating : 0;\n   const count = typeof p?.userRatingCount === \"number\" ? p.userRatingCount : 0;\n \n-  // Prefer well-rated, well-reviewed places.\n   const score = rating * 12 + Math.log10(Math.max(1, count)) * 8;\n \n-  // Small category boosts\n   const cat = pickCategory(p?.types);\n   const boost = cat === \"attraction\" ? 1.12 : cat === \"park\" ? 1.08 : 1.0;\n \n-  // Rider Mode: boost scenic/outdoors + one good food/coffee stop\n   if (riderMode) {\n     const t = Array.isArray(p?.types) ? (p.types as string[]) : [];\n     const scenicBoostTypes = new Set([\n       \"tourist_attraction\",\n@@ -176,24 +169,21 @@\n   return score * boost;\n }\n \n function desiredCategories(vibe: string, stopCount: number): (\"attraction\" | \"food\" | \"park\")[] {\n-  // 2 stops: always include an anchor + a food/coffee stop\n   if (stopCount === 2) return vibe === \"foodie\" ? [\"food\", \"attraction\"] : [\"attraction\", \"food\"];\n \n-  // 3 stops: vary the order by vibe\n   if (vibe === \"adventure\") return [\"park\", \"attraction\", \"food\"];\n   if (vibe === \"relaxed\") return [\"park\", \"food\", \"attraction\"];\n   if (vibe === \"foodie\") return [\"food\", \"attraction\", \"park\"];\n-  return [\"attraction\", \"food\", \"park\"]; // culture/default\n+  return [\"attraction\", \"food\", \"park\"];\n }\n \n function orderByNearestNeighbor(list: any[], riderMode?: boolean) {\n   if (list.length <= 2) return list;\n   const remaining = [...list];\n   const ordered: any[] = [];\n \n-  // Start with the best-scoring item.\n   remaining.sort((a, b) => scoreCandidate(b, riderMode) - scoreCandidate(a, riderMode));\n   ordered.push(remaining.shift());\n \n   while (remaining.length > 0) {\n@@ -227,9 +217,8 @@\n     \"Content-Type\": \"application/json\",\n     \"X-Goog-Api-Key\": key,\n     ...(rest.headers as Record<string, string> | undefined),\n   };\n-  // Places API (New) requires FieldMask for response fields\n   if (fieldMask) headers[\"X-Goog-FieldMask\"] = fieldMask;\n \n   return fetch(url, { ...rest, headers });\n }\n@@ -260,9 +249,8 @@\n   return (await res.json()) as any;\n }\n \n async function getPhotoUri(key: string, photoName: string, maxWidthPx = 900) {\n-  // /v1/{name}/media?maxWidthPx=...&skipHttpRedirect=true\n   const url = `https://places.googleapis.com/v1/${photoName}/media?maxWidthPx=${maxWidthPx}&skipHttpRedirect=true`;\n   const res = await googleFetch(url, { key, method: \"GET\", fieldMask: \"photoUri\" });\n   if (!res.ok) return undefined;\n   const data = await res.json();\n@@ -305,9 +293,8 @@\n     name: best?.displayName?.text ?? \"Parking\",\n     address: best?.formattedAddress,\n     lat: typeof loc?.latitude === \"number\" ? loc.latitude : undefined,\n     lng: typeof loc?.longitude === \"number\" ? loc.longitude : undefined,\n-    // mapsUri is NOT available from places:searchText results\n   } as ParkingOption;\n }\n \n async function enrichParkingMapsUri(key: string, parking?: ParkingOption) {\n@@ -348,8 +335,9 @@\n     const totalMinutes = clamp(Number(body?.totalMinutes ?? 150), 120, 180);\n     const vibe = String(body?.vibe ?? \"culture\");\n     const parkOnce = Boolean(body?.parkOnce);\n     const riderMode = Boolean(body?.riderMode);\n+    const bufferMinutes = clamp(Number(body?.bufferMinutes ?? 0), 0, 20);\n \n     if (!destination) {\n       return NextResponse.json({ error: \"Destination is required\" }, { status: 400 });\n     }\n@@ -370,14 +358,11 @@\n         : vibe === \"relaxed\"\n         ? `waterfront parks cafes in ${destination}`\n         : `top tourist attractions museums in ${destination}`;\n \n-    // Get a reasonable \"center\" for the destination (first result is usually the city/area).\n     const destPlaces = await searchPlacesText(key, destination, 3);\n     const destCenter = destPlaces?.[0]?.location as { latitude: number; longitude: number } | undefined;\n \n-    // Pull a larger pool so we can filter and pick better stops.\n-    // Use multiple queries to increase variety.\n     const qAttraction = `top attractions museums landmarks in ${destination}`;\n     const qFood = `best cafes restaurants bakeries in ${destination}`;\n     const qPark = `best parks viewpoints waterfront in ${destination}`;\n     const qScenic = `scenic viewpoints waterfront drives in ${destination}`;\n@@ -391,26 +376,24 @@\n       searchPlacesText(key, riderMode ? qScenic : qAttraction, 20),\n       searchPlacesText(key, riderMode ? qRideCoffee : qFood, 20),\n     ]);\n \n-    // Deduplicate by place id\n     const byId = new Map<string, any>();\n     for (const p of [...candA, ...candF, ...candP, ...candVibe, ...candScenic, ...candRideCoffee]) {\n       if (p?.id && !byId.has(p.id)) byId.set(p.id, p);\n     }\n     const pooled = Array.from(byId.values());\n \n     const stopCount = pickStopCount(totalMinutes);\n-    const radiusKm = 10; // keeps results local for city/area searches\n+    const radiusKm = 10;\n \n     const filtered = pooled\n       .filter((p) => p?.id && p?.location?.latitude != null && p?.location?.longitude != null)\n       .filter((p) => !isNoisyType(p?.types))\n       .filter((p) => {\n         const rating = typeof p?.rating === \"number\" ? p.rating : 0;\n         const count = typeof p?.userRatingCount === \"number\" ? p.userRatingCount : 0;\n \n-        // baseline quality: if it has reviews, enforce a decent rating\n         if (count >= 20 && rating > 0 && rating < 4.1) return false;\n         if (count >= 5 && rating > 0 && rating < 3.9) return false;\n \n         if (destCenter) {\n@@ -424,26 +407,21 @@\n     if (filtered.length < 2) {\n       return NextResponse.json({ error: \"Not enough high-quality places found\" }, { status: 404 });\n     }\n \n-    // Diversity selection: attraction + food + park (order varies by vibe)\n     const want = desiredCategories(vibe, stopCount);\n \n-    // If Park Once is enabled, prefer a tight cluster around the first (anchor) stop.\n-    // For walkable clusters, ~1.5km is a good starting point; relax to 3km if needed.\n     const walkKmPrimary = 1.5;\n     const walkKmRelaxed = 3;\n \n     const picked: any[] = [];\n \n-    // 1) Pick an anchor (first desired category) from overall filtered pool.\n     const anchorCat = want[0];\n     const anchor = filtered.find((p) => pickCategory(p?.types) === anchorCat) || filtered[0];\n     if (anchor) picked.push(anchor);\n \n     const anchorLoc = anchor?.location as { latitude: number; longitude: number } | undefined;\n \n-    // 2) Build a pool for subsequent picks.\n     const poolPrimary =\n       parkOnce && anchorLoc\n         ? filtered.filter((p) => {\n             const loc = p?.location as { latitude: number; longitude: number } | undefined;\n@@ -463,17 +441,15 @@\n \n     const pickFromPool = (pool: any[], cat: \"attraction\" | \"food\" | \"park\") =>\n       pool.find((p) => pickCategory(p?.types) === cat && !picked.some((x) => x.id === p.id));\n \n-    // 3) Fill remaining desired categories, preferring the tight pool.\n     for (const cat of want.slice(1)) {\n       let next = pickFromPool(poolPrimary, cat);\n       if (!next) next = pickFromPool(poolRelaxed, cat);\n       if (!next) next = pickFromPool(filtered, cat);\n       if (next) picked.push(next);\n     }\n \n-    // 4) If still short, fill from tight pool first, then relaxed, then overall.\n     const fillFrom = (pool: any[]) => {\n       while (picked.length < stopCount) {\n         const next = pool.find((p) => !picked.some((x) => x.id === p.id));\n         if (!next) break;\n@@ -484,16 +460,12 @@\n     fillFrom(poolPrimary);\n     fillFrom(poolRelaxed);\n     fillFrom(filtered);\n \n-    // Ordering:\n-    // - If Park Once: keep the anchor first then order rest by nearest-neighbor for minimal walking.\n-    // - Else: nearest-neighbor for minimal driving.\n     let ordered = parkOnce\n       ? [picked[0], ...orderByNearestNeighbor(picked.slice(1), riderMode)]\n       : orderByNearestNeighbor(picked, riderMode);\n \n-    // Rider mode: prefer a loose loop by ending near the anchor.\n     if (riderMode && ordered.length >= 3 && anchorLoc) {\n       const rest = ordered.slice(1);\n       rest.sort((a, b) => {\n         const la = a?.location as any;\n@@ -518,25 +490,21 @@\n         if (!placeId) throw new Error(\"Google Places returned an item without id\");\n \n         const details = await getPlaceDetails(key, placeId);\n \n-        // Photo\n         let photoUrl: string | undefined;\n         const firstPhotoName = details?.photos?.[0]?.name;\n         if (firstPhotoName) {\n           photoUrl = await getPhotoUri(key, firstPhotoName, 1000);\n         }\n \n-        // Reviews\n         const reviewSnippet = safeText(details?.reviews?.[0]?.text?.text, 170);\n \n-        // Opening hours\n         const openNow = details?.regularOpeningHours?.openNow;\n         const weekdayText = Array.isArray(details?.regularOpeningHours?.weekdayDescriptions)\n           ? (details.regularOpeningHours.weekdayDescriptions as string[])\n           : undefined;\n \n-        // Parking near each stop (best effort)\n         let parking: ParkingOption | undefined;\n         try {\n           const base = await findParkingNear(key, details?.displayName?.text ?? \"\", destination);\n           parking = await enrichParkingMapsUri(key, base);\n@@ -564,9 +532,8 @@\n         };\n       })\n     );\n \n-    // Optional: Park once near first stop, then walk between stops\n     let parkOnceLocation: ParkingOption | undefined;\n     if (parkOnce && stops.length > 0) {\n       try {\n         const base = await findParkingNear(key, stops[0].title, destination);\n@@ -577,18 +544,17 @@\n     }\n \n     const travelMins: number[] = [];\n \n-    // If parkOnce, add a first travel leg from parking -> first stop (WALK) and then walk between stops.\n     if (parkOnce && parkOnceLocation?.lat != null && parkOnceLocation?.lng != null && stops.length > 0) {\n       const firstStop = stops[0];\n       const fromParkingToFirst = await computeRouteMinutes(\n         key,\n         { latitude: parkOnceLocation.lat, longitude: parkOnceLocation.lng },\n         { latitude: firstStop.lat, longitude: firstStop.lng },\n         \"WALK\"\n       );\n-      travelMins.push(fromParkingToFirst);\n+      travelMins.push(fromParkingToFirst + bufferMinutes);\n \n       for (let i = 0; i < stops.length - 1; i++) {\n         const a = stops[i];\n         const b = stops[i + 1];\n@@ -597,12 +563,11 @@\n           { latitude: a.lat, longitude: a.lng },\n           { latitude: b.lat, longitude: b.lng },\n           \"WALK\"\n         );\n-        travelMins.push(mins);\n+        travelMins.push(mins + bufferMinutes);\n       }\n     } else {\n-      // Default: DRIVE between stops\n       for (let i = 0; i < stops.length - 1; i++) {\n         const a = stops[i];\n         const b = stops[i + 1];\n         const mins = await computeRouteMinutes(\n@@ -610,9 +575,9 @@\n           { latitude: a.lat, longitude: a.lng },\n           { latitude: b.lat, longitude: b.lng },\n           \"DRIVE\"\n         );\n-        travelMins.push(mins);\n+        travelMins.push(mins + bufferMinutes);\n       }\n     }\n \n     const travelTotal = travelMins.reduce((x, y) => x + y, 0);\n@@ -620,9 +585,8 @@\n \n     const items: PlanItem[] = [];\n \n     if (parkOnce && parkOnceLocation?.lat != null && parkOnceLocation?.lng != null) {\n-      // Add a parking stop card first (5 min buffer)\n       items.push({\n         type: \"stop\",\n         durationMin: 5,\n         placeId: parkOnceLocation.placeId || \"parking\",\n@@ -647,13 +611,12 @@\n           mapsUri: parkOnceLocation.mapsUri,\n         },\n       });\n \n-      // Travel leg from parking -> first stop (WALK) is travelMins[0]\n       if (travelMins.length > 0) {\n         items.push({\n           type: \"travel\",\n-          title: \"Walk to first stop\",\n+          title: `Walk to ${stops[0]?.title ?? \"first stop\"}`,\n           durationMin: travelMins[0],\n           mode: \"WALK\",\n         });\n       }\n@@ -663,22 +626,21 @@\n         if (i < stops.length - 1) {\n           const leg = travelMins[i + 1] ?? 10;\n           items.push({\n             type: \"travel\",\n-            title: \"Walk to next stop\",\n+            title: `Walk to ${stops[i + 1]?.title ?? \"next stop\"}`,\n             durationMin: leg,\n             mode: \"WALK\",\n           });\n         }\n       }\n     } else {\n-      // Default DRIVE itinerary\n       for (let i = 0; i < stops.length; i++) {\n         items.push({ type: \"stop\", durationMin: Math.max(25, stopDurations[i] ?? 40), ...stops[i] });\n         if (i < travelMins.length) {\n           items.push({\n             type: \"travel\",\n-            title: \"Drive to next stop\",\n+            title: `Drive to ${stops[i + 1]?.title ?? \"next stop\"}`,\n             durationMin: travelMins[i],\n             mode: \"DRIVE\",\n           });\n         }\n@@ -690,8 +652,9 @@\n       totalMinutes,\n       vibe,\n       parkOnce,\n       riderMode,\n+      bufferMinutes,\n       source: \"google\",\n       items,\n     });\n   } catch (e) {\n"
                },
                {
                    "date": 1766872661594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -242,9 +242,9 @@\n   const res = await googleFetch(url, {\n     key,\n     method: \"GET\",\n     fieldMask:\n-      \"id,displayName,formattedAddress,location,rating,userRatingCount,priceLevel,regularOpeningHours,photos,reviews,googleMapsUri\",\n+      \"id,displayName,formattedAddress,location,types,rating,userRatingCount,priceLevel,regularOpeningHours,photos,reviews,googleMapsUri\",\n   });\n   if (!res.ok) throw new Error(await res.text());\n   return (await res.json()) as any;\n }\n@@ -330,8 +330,295 @@\n \n   try {\n     const body = await req.json().catch(() => ({}));\n \n+    const action = String(body?.action ?? \"\").trim();\n+\n+    // -----------------------------\n+    // SWAP STOP (replace only 1 stop)\n+    // -----------------------------\n+    if (action === \"swap\") {\n+      const destination = String(body?.destination ?? \"\").trim();\n+      const totalMinutes = clamp(Number(body?.totalMinutes ?? 150), 120, 180);\n+      const vibe = String(body?.vibe ?? \"culture\");\n+      const parkOnce = Boolean(body?.parkOnce);\n+      const riderMode = Boolean(body?.riderMode);\n+      const bufferMinutes = clamp(Number(body?.bufferMinutes ?? 0), 0, 20);\n+\n+      const swapIndex = clamp(Number(body?.swapIndex ?? -1), 0, 10);\n+      const swapPlaceId = String(body?.swapPlaceId ?? \"\").trim();\n+      const swapLat = Number(body?.swapLat);\n+      const swapLng = Number(body?.swapLng);\n+\n+      const rawStops = Array.isArray(body?.stops) ? body.stops : [];\n+\n+      if (!destination) {\n+        return NextResponse.json({ error: \"Destination is required\" }, { status: 400 });\n+      }\n+\n+      const key = process.env.GOOGLE_MAPS_API_KEY;\n+      if (!key) {\n+        return NextResponse.json(\n+          { error: \"Missing GOOGLE_MAPS_API_KEY. Add it to .env.local and restart npm run dev.\" },\n+          { status: 500 }\n+        );\n+      }\n+\n+      const stopsInput = rawStops\n+        .map((s: any) => ({\n+          placeId: String(s?.placeId ?? \"\").trim(),\n+          title: String(s?.title ?? \"\").trim(),\n+          durationMin: clamp(Number(s?.durationMin ?? 40), 20, 180),\n+          lat: Number(s?.lat),\n+          lng: Number(s?.lng),\n+        }))\n+        .filter((s: any) => s.placeId);\n+\n+      if (stopsInput.length < 2) {\n+        return NextResponse.json({ error: \"Not enough stops to swap\" }, { status: 400 });\n+      }\n+\n+      if (swapIndex < 0 || swapIndex >= stopsInput.length) {\n+        return NextResponse.json({ error: \"Invalid swap index\" }, { status: 400 });\n+      }\n+\n+      const currentStop = stopsInput[swapIndex];\n+      const centerLat = Number.isFinite(swapLat) ? swapLat : currentStop?.lat;\n+      const centerLng = Number.isFinite(swapLng) ? swapLng : currentStop?.lng;\n+\n+      if (!swapPlaceId || !Number.isFinite(centerLat) || !Number.isFinite(centerLng)) {\n+        return NextResponse.json({ error: \"Invalid swap request\" }, { status: 400 });\n+      }\n+\n+      // Determine category of the stop being swapped using its current place types\n+      let swapTypes: string[] = [];\n+      try {\n+        const d = await getPlaceDetails(key, swapPlaceId);\n+        swapTypes = Array.isArray(d?.types) ? (d.types as string[]) : [];\n+      } catch {\n+        swapTypes = [];\n+      }\n+\n+      const targetCategory = pickCategory(swapTypes);\n+\n+      const qNearby =\n+        targetCategory === \"food\"\n+          ? `cafes restaurants near ${centerLat},${centerLng}`\n+          : targetCategory === \"park\"\n+          ? `parks viewpoints near ${centerLat},${centerLng}`\n+          : `tourist attractions museums near ${centerLat},${centerLng}`;\n+\n+      let candidates: any[] = [];\n+      try {\n+        candidates = await searchPlacesText(key, qNearby, 30);\n+      } catch {\n+        candidates = [];\n+      }\n+\n+      const excludeIds = new Set(stopsInput.map((s: any) => s.placeId));\n+      excludeIds.delete(swapPlaceId);\n+\n+      const swapCenter: LatLng = { latitude: centerLat, longitude: centerLng };\n+      const maxKm = parkOnce ? 2.0 : 4.0;\n+\n+      const filtered = candidates\n+        .filter((p) => p?.id && p?.location?.latitude != null && p?.location?.longitude != null)\n+        .filter((p) => !excludeIds.has(String(p.id)))\n+        .filter((p) => !isNoisyType(p?.types))\n+        .filter((p) => pickCategory(p?.types) === targetCategory)\n+        .filter((p) => haversineKm(swapCenter, p.location) <= maxKm)\n+        .sort((a, b) => scoreCandidate(b, riderMode) - scoreCandidate(a, riderMode));\n+\n+      const replacement = filtered[0];\n+      if (!replacement?.id) {\n+        return NextResponse.json({ error: \"No replacement found nearby\" }, { status: 404 });\n+      }\n+\n+      // Replace only the swapped stop's placeId; keep durations exactly as provided\n+      const nextStops = [...stopsInput];\n+      nextStops[swapIndex] = {\n+        ...nextStops[swapIndex],\n+        placeId: String(replacement.id),\n+      };\n+\n+      // Enrich all stops with place details (2â€“3 stops only)\n+      const stops: StopDetails[] = await Promise.all(\n+        nextStops.map(async (s: any) => {\n+          const details = await getPlaceDetails(key, s.placeId);\n+\n+          let photoUrl: string | undefined;\n+          const firstPhotoName = details?.photos?.[0]?.name;\n+          if (firstPhotoName) {\n+            photoUrl = await getPhotoUri(key, firstPhotoName, 1000);\n+          }\n+\n+          const reviewSnippet = safeText(details?.reviews?.[0]?.text?.text, 170);\n+          const openNow = details?.regularOpeningHours?.openNow;\n+          const weekdayText = Array.isArray(details?.regularOpeningHours?.weekdayDescriptions)\n+            ? (details.regularOpeningHours.weekdayDescriptions as string[])\n+            : undefined;\n+\n+          let parking: ParkingOption | undefined;\n+          try {\n+            const base = await findParkingNear(key, details?.displayName?.text ?? \"\", destination);\n+            parking = await enrichParkingMapsUri(key, base);\n+          } catch {\n+            parking = undefined;\n+          }\n+\n+          return {\n+            placeId: String(s.placeId),\n+            title: details?.displayName?.text ?? s.title ?? \"Place\",\n+            address: details?.formattedAddress,\n+            lat: Number(details?.location?.latitude),\n+            lng: Number(details?.location?.longitude),\n+            mapsUri: details?.googleMapsUri,\n+\n+            rating: typeof details?.rating === \"number\" ? details.rating : undefined,\n+            userRatingCount:\n+              typeof details?.userRatingCount === \"number\" ? details.userRatingCount : undefined,\n+            priceLevel: typeof details?.priceLevel === \"string\" ? details.priceLevel : undefined,\n+            openNow: typeof openNow === \"boolean\" ? openNow : undefined,\n+            weekdayText,\n+            photoUrl,\n+            reviewSnippet,\n+            parking,\n+          } as StopDetails;\n+        })\n+      );\n+\n+      // Park-once anchor parking near the FIRST stop\n+      let parkOnceLocation: ParkingOption | undefined;\n+      if (parkOnce && stops.length > 0) {\n+        try {\n+          const base = await findParkingNear(key, stops[0].title, destination);\n+          parkOnceLocation = await enrichParkingMapsUri(key, base);\n+        } catch {\n+          parkOnceLocation = undefined;\n+        }\n+      }\n+\n+      // Compute travel legs\n+      const travelMins: number[] = [];\n+\n+      if (parkOnce && parkOnceLocation?.lat != null && parkOnceLocation?.lng != null && stops.length > 0) {\n+        const firstStop = stops[0];\n+        const fromParkingToFirst = await computeRouteMinutes(\n+          key,\n+          { latitude: parkOnceLocation.lat, longitude: parkOnceLocation.lng },\n+          { latitude: firstStop.lat, longitude: firstStop.lng },\n+          \"WALK\"\n+        );\n+        travelMins.push(fromParkingToFirst + bufferMinutes);\n+\n+        for (let i = 0; i < stops.length - 1; i++) {\n+          const a = stops[i];\n+          const b = stops[i + 1];\n+          const mins = await computeRouteMinutes(\n+            key,\n+            { latitude: a.lat, longitude: a.lng },\n+            { latitude: b.lat, longitude: b.lng },\n+            \"WALK\"\n+          );\n+          travelMins.push(mins + bufferMinutes);\n+        }\n+      } else {\n+        for (let i = 0; i < stops.length - 1; i++) {\n+          const a = stops[i];\n+          const b = stops[i + 1];\n+          const mins = await computeRouteMinutes(\n+            key,\n+            { latitude: a.lat, longitude: a.lng },\n+            { latitude: b.lat, longitude: b.lng },\n+            \"DRIVE\"\n+          );\n+          travelMins.push(mins + bufferMinutes);\n+        }\n+      }\n+\n+      // Preserve stop durations exactly from the client\n+      const stopDurations = nextStops.map((s: any) => clamp(Number(s?.durationMin ?? 40), 20, 180));\n+\n+      const items: PlanItem[] = [];\n+\n+      if (parkOnce && parkOnceLocation?.lat != null && parkOnceLocation?.lng != null) {\n+        items.push({\n+          type: \"stop\",\n+          durationMin: 5,\n+          placeId: parkOnceLocation.placeId || \"parking\",\n+          title: \"Park once\",\n+          address: parkOnceLocation.address,\n+          lat: parkOnceLocation.lat,\n+          lng: parkOnceLocation.lng,\n+          mapsUri: parkOnceLocation.mapsUri,\n+          rating: undefined,\n+          userRatingCount: undefined,\n+          priceLevel: undefined,\n+          openNow: undefined,\n+          weekdayText: undefined,\n+          photoUrl: undefined,\n+          reviewSnippet: undefined,\n+          parking: {\n+            placeId: parkOnceLocation.placeId,\n+            name: parkOnceLocation.name,\n+            address: parkOnceLocation.address,\n+            lat: parkOnceLocation.lat,\n+            lng: parkOnceLocation.lng,\n+            mapsUri: parkOnceLocation.mapsUri,\n+          },\n+        });\n+\n+        if (travelMins.length > 0) {\n+          items.push({\n+            type: \"travel\",\n+            title: `Walk to ${stops[0]?.title ?? \"first stop\"}`,\n+            durationMin: travelMins[0],\n+            mode: \"WALK\",\n+          });\n+        }\n+\n+        for (let i = 0; i < stops.length; i++) {\n+          items.push({ type: \"stop\", durationMin: stopDurations[i] ?? 40, ...stops[i] });\n+          if (i < stops.length - 1) {\n+            const leg = travelMins[i + 1] ?? 10;\n+            items.push({\n+              type: \"travel\",\n+              title: `Walk to ${stops[i + 1]?.title ?? \"next stop\"}`,\n+              durationMin: leg,\n+              mode: \"WALK\",\n+            });\n+          }\n+        }\n+      } else {\n+        for (let i = 0; i < stops.length; i++) {\n+          items.push({ type: \"stop\", durationMin: stopDurations[i] ?? 40, ...stops[i] });\n+          if (i < travelMins.length) {\n+            items.push({\n+              type: \"travel\",\n+              title: `Drive to ${stops[i + 1]?.title ?? \"next stop\"}`,\n+              durationMin: travelMins[i],\n+              mode: \"DRIVE\",\n+            });\n+          }\n+        }\n+      }\n+\n+      return NextResponse.json({\n+        destination,\n+        totalMinutes,\n+        vibe,\n+        parkOnce,\n+        riderMode,\n+        bufferMinutes,\n+        source: \"google\",\n+        items,\n+      });\n+    }\n+\n+    // --------\n+    // EXISTING LOGIC BELOW (for non-swap)\n+    // --------\n+\n     const destination = String(body?.destination ?? \"\").trim();\n     const totalMinutes = clamp(Number(body?.totalMinutes ?? 150), 120, 180);\n     const vibe = String(body?.vibe ?? \"culture\");\n     const parkOnce = Boolean(body?.parkOnce);\n@@ -371,9 +658,9 @@\n     const [candA, candF, candP, candVibe, candScenic, candRideCoffee] = await Promise.all([\n       searchPlacesText(key, qAttraction, 20),\n       searchPlacesText(key, qFood, 20),\n       searchPlacesText(key, qPark, 20),\n-      searchPlacesText(key, query, 20),\n+      searchPlacesText(key, qScenic, 20),\n       searchPlacesText(key, riderMode ? qScenic : qAttraction, 20),\n       searchPlacesText(key, riderMode ? qRideCoffee : qFood, 20),\n     ]);\n \n"
                }
            ],
            "date": 1766824749075,
            "name": "Commit-0",
            "content": "\n\nimport { NextResponse } from \"next/server\";\n\n// This route builds a 2â€“3 hour itinerary.\n// For now it returns a safe fallback plan.\n// You can later replace the body with Google Places + Routes logic.\n\nexport async function POST(req: Request) {\n  try {\n    const body = await req.json();\n    const destination = String(body?.destination ?? \"\").trim();\n    const totalMinutes = Number(body?.totalMinutes ?? 150);\n    const vibe = String(body?.vibe ?? \"culture\");\n\n    if (!destination) {\n      return NextResponse.json({ error: \"Destination is required\" }, { status: 400 });\n    }\n\n    const minutes = clamp(totalMinutes, 120, 180);\n\n    // Simple 2â€“3 hour structure\n    const stopCount = minutes <= 140 ? 2 : 3;\n    const travelMinEach = 12;\n    const travelTotal = (stopCount - 1) * travelMinEach;\n    const remaining = Math.max(60, minutes - travelTotal);\n\n    const stopDurations =\n      stopCount === 2\n        ? [Math.floor(remaining * 0.55), remaining - Math.floor(remaining * 0.55)]\n        : [\n            Math.floor(remaining * 0.42),\n            Math.floor(remaining * 0.35),\n            remaining - Math.floor(remaining * 0.42) - Math.floor(remaining * 0.35),\n          ];\n\n    const byVibe: Record<string, string[]> = {\n      relaxed: [\"Waterfront stroll\", \"Coffee break\", \"Scenic viewpoint\"],\n      foodie: [\"Top-rated cafÃ©\", \"Local specialty\", \"Dessert stop\"],\n      adventure: [\"Easy trail\", \"Lookout point\", \"Recovery cafÃ©\"],\n      culture: [\"Museum or gallery\", \"Historic walk\", \"Local landmark\"],\n    };\n\n    const titles = byVibe[vibe] ?? byVibe.culture;\n\n    const items: Array<{\n      type: \"stop\" | \"travel\";\n      title: string;\n      durationMin: number;\n    }> = [];\n\n    for (let i = 0; i < stopCount; i++) {\n      items.push({\n        type: \"stop\",\n        title: `${titles[i] ?? \"Stop\"} in ${destination}`,\n        durationMin: Math.max(25, stopDurations[i]),\n      });\n\n      if (i < stopCount - 1) {\n        items.push({\n          type: \"travel\",\n          title: \"Walk to next stop\",\n          durationMin: travelMinEach,\n        });\n      }\n    }\n\n    return NextResponse.json({\n      destination,\n      totalMinutes: minutes,\n      vibe,\n      items,\n    });\n  } catch (err) {\n    return NextResponse.json(\n      { error: \"Failed to generate itinerary\" },\n      { status: 500 }\n    );\n  }\n}\n\nfunction clamp(n: number, min: number, max: number) {\n  if (!Number.isFinite(n)) return min;\n  return Math.max(min, Math.min(max, n));\n}"
        }
    ]
}